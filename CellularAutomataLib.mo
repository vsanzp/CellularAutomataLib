package CellularAutomataLib
  class LICENSE
    extends Modelica.Icons.Information;

    annotation (preferredView = "info",
    Documentation(info="<html>
<p>                   GNU LESSER GENERAL PUBLIC LICENSE</p>
<p>                       Version 3, 29 June 2007</p>
<p>Copyright (C) 2007 Free Software Foundation, Inc. &lt;https://fsf.org/&gt;<br>
Everyone is permitted to copy and distribute verbatim copies<br>
of this license document, but changing it is not allowed.</p>

<p>This version of the GNU Lesser General Public License incorporates<br>
the terms and conditions of version 3 of the GNU General Public<br>
License, supplemented by the additional permissions listed below.</p>

<p>0. Additional Definitions.</p>

<p>As used herein, &quot;this License&quot; refers to version 3 of the GNU Lesser<br>
General Public License, and the &quot;GNU GPL&quot; refers to version 3 of the GNU<br>
General Public License.</p>

<p>&quot;The Library&quot; refers to a covered work governed by this License,<br>
other than an Application or a Combined Work as defined below.</p>

<p>An &quot;Application&quot; is any work that makes use of an interface provided<br>
by the Library, but which is not otherwise based on the Library.<br>
Defining a subclass of a class defined by the Library is deemed a mode<br>
of using an interface provided by the Library.</p>

<p>A &quot;Combined Work&quot; is a work produced by combining or linking an<br>
Application with the Library.  The particular version of the Library<br>
with which the Combined Work was made is also called the &quot;Linked<br>
Version&quot;.</p>

<p>The &quot;Minimal Corresponding Source&quot; for a Combined Work means the<br>
Corresponding Source for the Combined Work, excluding any source code<br>
for portions of the Combined Work that, considered in isolation, are<br>
based on the Application, and not on the Linked Version.</p>

<p>The &quot;Corresponding Application Code&quot; for a Combined Work means the<br>
object code and/or source code for the Application, including any data<br>
and utility programs needed for reproducing the Combined Work from the<br>
Application, but excluding the System Libraries of the Combined Work.</p>

<p>1. Exception to Section 3 of the GNU GPL.</p>

<p>You may convey a covered work under sections 3 and 4 of this License<br>
without being bound by section 3 of the GNU GPL.</p>

<p>2. Conveying Modified Versions.</p>

<p>If you modify a copy of the Library, and, in your modifications, a<br>
facility refers to a function or data to be supplied by an Application<br>
that uses the facility (other than as an argument passed when the<br>
facility is invoked), then you may convey a copy of the modified<br>
version:</p>

<p>&nbsp;&nbsp; a) under this License, provided that you make a good faith effort to<br>
   &nbsp;&nbsp;ensure that, in the event an Application does not supply the<br>
   &nbsp;&nbsp;function or data, the facility still operates, and performs<br>
   &nbsp;&nbsp;whatever part of its purpose remains meaningful, or</p>
<p>&nbsp;&nbsp;   b) under the GNU GPL, with none of the additional permissions of<br>
   &nbsp;&nbsp;this License applicable to that copy.</p>

<p>  3. Object Code Incorporating Material from Library Header Files.</p>

<p>  The object code form of an Application may incorporate material from<br>
a header file that is part of the Library.  You may convey such object<br>
code under terms of your choice, provided that, if the incorporated<br>
material is not limited to numerical parameters, data structure<br>
layouts and accessors, or small macros, inline functions and templates<br>
(ten or fewer lines in length), you do both of the following:</p>

<p>&nbsp;&nbsp;   a) Give prominent notice with each copy of the object code that the<br>
  &nbsp;&nbsp;Library is used in it and that the Library and its use are<br>
  &nbsp;&nbsp; covered by this License.</p>

<p>&nbsp;&nbsp;   b) Accompany the object code with a copy of the GNU GPL and this license<br>
  &nbsp;&nbsp;document.</p>

<p><br>  4. Combined Works.</p>

<p>  You may convey a Combined Work under terms of your choice that,<br>
taken together, effectively do not restrict modification of the<br>
portions of the Library contained in the Combined Work and reverse<br>
engineering for debugging such modifications, if you also do each of<br>
the following:</p>

<p>&nbsp;&nbsp;   a) Give prominent notice with each copy of the Combined Work that<br>
   &nbsp;&nbsp;the Library is used in it and that the Library and its use are<br>
   &nbsp;&nbsp;covered by this License.</p>

<p>&nbsp;&nbsp;   b) Accompany the Combined Work with a copy of the GNU GPL and this license<br>
  &nbsp;&nbsp;document.</p>

<p>&nbsp;&nbsp;   c) For a Combined Work that displays copyright notices during<br>
  &nbsp;&nbsp;execution, include the copyright notice for the Library among<br>
  &nbsp;&nbsp;these notices, as well as a reference directing the user to the<br>
  &nbsp;&nbsp;copies of the GNU GPL and this license document.</p>

<p>&nbsp;&nbsp;   d) Do one of the following:</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;       0) Convey the Minimal Corresponding Source under the terms of this<br>
   &nbsp;&nbsp;&nbsp;&nbsp;   License, and the Corresponding Application Code in a form<br>
   &nbsp;&nbsp;&nbsp;&nbsp;    suitable for, and under terms that permit, the user to<br>
   &nbsp;&nbsp;&nbsp;&nbsp;    recombine or relink the Application with a modified version of<br>
   &nbsp;&nbsp;&nbsp;&nbsp;    the Linked Version to produce a modified Combined Work, in the<br>
   &nbsp;&nbsp;&nbsp;&nbsp;    manner specified by section 6 of the GNU GPL for conveying<br>
   &nbsp;&nbsp;&nbsp;&nbsp;    Corresponding Source.</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;       1) Use a suitable shared library mechanism for linking with the<br>
   &nbsp;&nbsp;&nbsp;&nbsp;    Library.  A suitable mechanism is one that (a) uses at run time<br>
   &nbsp;&nbsp;&nbsp;&nbsp;    a copy of the Library already present on the user&apos;s computer<br>
   &nbsp;&nbsp;&nbsp;&nbsp;    system, and (b) will operate properly with a modified version<br>
   &nbsp;&nbsp;&nbsp;&nbsp;    of the Library that is interface-compatible with the Linked<br>
   &nbsp;&nbsp;&nbsp;&nbsp;    Version.</p>

<p>&nbsp;&nbsp;   e) Provide Installation Information, but only if you would otherwise<br>
   &nbsp;&nbsp;be required to provide such information under section 6 of the<br>
   &nbsp;&nbsp;GNU GPL, and only to the extent that such information is<br>
   &nbsp;&nbsp;necessary to install and execute a modified version of the<br>
   &nbsp;&nbsp;Combined Work produced by recombining or relinking the<br>
   &nbsp;&nbsp;Application with a modified version of the Linked Version. (If<br>
   &nbsp;&nbsp;you use option 4d0, the Installation Information must accompany<br>
   &nbsp;&nbsp;the Minimal Corresponding Source and Corresponding Application<br>
   &nbsp;&nbsp;Code. If you use option 4d1, you must provide the Installation<br>
   &nbsp;&nbsp;Information in the manner specified by section 6 of the GNU GPL<br>
   &nbsp;&nbsp;for conveying Corresponding Source.)</p>

<p>  5. Combined Libraries.</p>

<p>  You may place library facilities that are a work based on the<br>
Library side by side in a single library together with other library<br>
facilities that are not Applications and are not covered by this<br>
License, and convey such a combined library under terms of your<br>
choice, if you do both of the following:</p>

<p>&nbsp;&nbsp;   a) Accompany the combined library with a copy of the same work based<br>
   &nbsp;&nbsp;on the Library, uncombined with any other library facilities,<br>
   &nbsp;&nbsp;conveyed under the terms of this License.</p>

<p>&nbsp;&nbsp;   b) Give prominent notice with the combined library that part of it<br>
   &nbsp;&nbsp;is a work based on the Library, and explaining where to find the<br>
   &nbsp;&nbsp;accompanying uncombined form of the same work.</p>

<p>  6. Revised Versions of the GNU Lesser General Public License.</p>

<p>  The Free Software Foundation may publish revised and/or new versions<br>
of the GNU Lesser General Public License from time to time. Such new<br>
versions will be similar in spirit to the present version, but may<br>
differ in detail to address new problems or concerns.</p>

<p>  Each version is given a distinguishing version number. If the<br>
Library as you received it specifies that a certain numbered version<br>
of the GNU Lesser General Public License &quot;or any later version&quot;<br>
applies to it, you have the option of following the terms and<br>
conditions either of that published version or of any later version<br>
published by the Free Software Foundation. If the Library as you<br>
received it does not specify a version number of the GNU Lesser<br>
General Public License, you may choose any version of the GNU Lesser<br>
General Public License ever published by the Free Software Foundation.</p>

<p>  If the Library as you received it specifies that a proxy can decide<br>
whether future versions of the GNU Lesser General Public License shall<br>
apply, that proxy&apos;s public statement of acceptance of any version is<br>
permanent authorization for you to choose that version for the<br>
Library.</p>
</html>"));
  end LICENSE;

  class Documentation "Users Guide"
    extends Modelica.Icons.Information;

    class NewModels "Development of new CA models"
      extends Modelica.Icons.Information;
      annotation (
       preferredView = "info",
        Documentation(info="<html>
<p><b><span style=\"color: #008000;\">Development of new cellular automata models using <i>CellularAutomataLib2</span></b></i></p>
<p>A model in <i>CellularAutomataLib</i> is composed of a cellular space, that represents the lattice of cells, including their state (S) and the transition function (&delta;), and some models, named interface models (i.e., inputs X, &Omega;, and outputs Y, &lambda;), used as interface between different cellular spaces, or between cellular spaces and other models.</p>
<p><i>CellularAutomataLib</i> models are composed of a combination of Modelica code and C code. Cellular spaces and interface models are described using Modelica. However, the behavior of cellular spaces and interfaces, and the CA simulation algorithm are implemented using external C functions that are related to their corresponding Modelica models using the external function interface. In this way, the external C code is not involved in the automatic translation of the Modelica model, which improves the scalability and the performance of the simulations.</p>
<p>The relationship between the external C code and the Modelica code is summarized in the figure below. The file <span style=\"font-family: Courier New;\">CellularAutomataLib.c</span> contains C code used to describe general data structures (e.g., cellular spaces and cells) and functions to implement the CA simulation algorithm. These data structures and functions are common to all CA and should not be modified by the user. The behavior of the model should be defined in another file (e.g.,<span style=\"font-family: Courier New;\"> Model.c</span><span style=\"font-family: Sans Serif;\">)</span>, where the user has to implement the data structure used to describe the state of the cells, its default and initial values and the transition rule. <span style=\"font-family: Courier New;\">CellularAutomataLib.c</span> has to be included in <span style=\"font-family: Courier New;\">Model.c</span> in order to use the basic functionality of the library. Once the behavior of the automaton is described in C, the user can describe the cellular spaces and their interfaces using Modelica and relate them with the behavior defined in C. Finally, cellular spaces and interface models can be combined, by means of instances, to describe more complex CA models (e.g., that may include multiple inter-connected cellular spaces and interfaces). </p>
<p><span style=\"font-family: Sans Serif;\"><img src=\"modelica://CellularAutomataLib/FIGS/diagram.png\"/></span></p>
<p>The procedure to create a cellular automata model can be divided in the following steps: </p>
<h4><span style=\"color: #008000\">1. Description of the Cell State and Rule using External C Code.</span></h4>
<p>In order to facilitate the description of the behavior of new cellular spaces, the library includes a template file (named <span style=\"font-family: Courier New;\">draft.c</span>) that can be used to describe the required external C functions.</p>
<p>Following the formal specification of the automata, the user has to define the state variables that represent the state of the cells (S) and the model behavior (i.e., the transition function &delta;) by reimplementing the functions included in the <span style=\"font-family: Courier New;\">draft.c</span> file, into a new file (e.g., <span style=\"font-family: Courier New;\">model.c</span>). The time base T is set using the parameters <span style=\"font-family: Courier New;\">TStep</span> and <span style=\"font-family: Courier New;\">Initial step</span> of the cellular space model. The rest of the elements of the tuple (X, &Omega;, Y, &lambda;) are defined using the interface models.</p>
<p>As an example, the development of the Rule30 model described by Wolfram is presented. The transition function for this model is shown in the next figure.</p>
<p><img src=\"modelica://CellularAutomataLib/FIGS/rule30.png\"/></p>
<p>The<span style=\"font-family: Courier New;\"> draft.c </span>file can be used as a template to describe the behavior of the model. It has been renamed as <span style=\"font-family: Courier New;\">wolfram.c</span> for this example.</p>
<p>The C code corresponding to the description of the state, default and initial functions is shown in file<span style=\"font-family: Courier New;\"> wolfram.c</span>. The state of each cell is defined as an <span style=\"font-family: Courier New;\">int</span> value by modifying the <span style=\"font-family: Courier New;\">State</span> data type in the template (now <span style=\"font-family: Courier New;\">RState</span>). The default value for the cell state will be set using the <span style=\"font-family: Courier New;\">RDefaultState</span> function, and so it has to be modified to set the default state to 0. The <span style=\"font-family: Courier New;\">Default</span> function of the <span style=\"font-family: Courier New;\">CellSpace</span> model will be redeclared using the function <span style=\"font-family: Courier New;\">RDefault</span>, that includes a pointer to <span style=\"font-family: Courier New;\">RDefaultState</span> and a call to the <span style=\"font-family: Courier New;\">CS_InitDefault</span> function, used to set the default state in the cellular space. The state of initialized cells will be set using the <span style=\"font-family: Courier New;\">RInitialState</span> function, and so it has to be modified to set the initial state to 1. The <span style=\"font-family: Courier New;\">RInit </span>function will be used to redeclare the <span style=\"font-family: Courier New;\">Initial</span> function of the <span style=\"font-family: Courier New;\">CellSpace</span> model.</p>
<p>The transition function shown above has to be implemented by modifying the <span style=\"font-family: Courier New;\">transition</span> function in the template (cf. <span style=\"font-family: Courier New;\">rule30</span> function in <span style=\"font-family: Courier New;\">wolfram.c</span>). In order to automatically generate the graphical animation, the <span style=\"font-family: Courier New;\">Display</span> function in the template (now <span style=\"font-family: Courier New;\">RDisplay</span>) has to be modified to convert the state of the cell (i.e., the <span style=\"font-family: Courier New;\">RState</span> data type) into a <span style=\"font-family: Courier New;\">double</span> value that corresponds to the color that will be displayed for the cell in the animation. The corresponding C code is also shown in file <span style=\"font-family: Courier New;\">wolfram.c</span>. </p>
<h4><span style=\"color: #008000\">2. Description of New Cellular Spaces in Modelica.</span></h4>
<p>A cellular space in <i>CellularAutomataLib</i> is composed of the <span style=\"font-family: Courier New;\">CS</span> external object that represents the space; and the cellular space model used to simulate it (<span style=\"font-family: Courier New;\">CellSpace</span>). The external object represents the data structure used to store the information about the space during the simulation. Two functions, <span style=\"font-family: Courier New;\">constructor</span> and <span style=\"font-family: Courier New;\">destructor</span>, are used to initialize this data structure at the beginning of the simulation and destroy it at the end.</p>
<p>The <span style=\"font-family: Courier New;\">CellSpace</span> model is defined as a partial model (i.e., a model that can not be directly instantiated) that describes the multi-dimensional space represented by the automaton, and includes the code used to simulate the automaton. Each cellular space instantiates a <span style=\"font-family: Courier New;\">CS</span> external object to represent the space. The characteristics of the <span style=\"font-family: Courier New;\">CellSpace</span> model have to be inherited by another model (i.e., using the extends Modelica clause) in order to define a new cellular space. The cellular space model includes three local functions: <span style=\"font-family: Courier New;\">Default</span>, that is used to define the default state of the cells (i.e., cells not initially active). <span style=\"font-family: Courier New;\">Initial</span>, that is used to initialize the state of the cells indicated using the <span style=\"font-family: Courier New;\">init_cells</span> parameter, and activate them; and <span style=\"font-family: Courier New;\">Rule</span>, that represents the transition function and is used to update the state of the cells at each simulation step.</p>
<p>At the beginning of the simulation, the <span style=\"font-family: Courier New;\">CS</span> external object is initialized using its constructor function, the cellular space defines the default state using the <span style=\"font-family: Courier New;\">Default</span> function and initializes the cells indicated in the <span style=\"font-family: Courier New;\">init_cells</span> parameter using the <span style=\"font-family: Courier New;\">Initial</span> function. After that, it performs periodic simulation steps every <span style=\"font-family: Courier New;\">Tstep</span> time by executing the <span style=\"font-family: Courier New;\">Rule</span> function, starting at time = Initial step (i.e., <span style=\"font-family: Courier New;\">sample(Initial step,Tstep)</span>). The behavior of the cellular space is described by re-declaring these local functions with other Modelica functions that call external C functions, that contain the desired behavior (e.g., functions implemented using the <span style=\"font-family: Courier New;\">draft.c</span> file).</p>
<p>Following the example of the Rule30 model, the cellular space is described in Modelica by extending the <span style=\"font-family: Courier New;\">CellSpace</span> model. The <span style=\"font-family: Courier New;\">Default</span>, <span style=\"font-family: Courier New;\">Initial</span> and <span style=\"font-family: Courier New;\">Rule</span> functions of the new cellular space have to be redeclared with functions that call the <span style=\"font-family: Courier New;\">RDefault</span>, <span style=\"font-family: Courier New;\">RInitial</span> and <span style=\"font-family: Courier New;\">R30Step</span> functions previously defined in <span style=\"font-family: Courier New;\">wolfram.c</span>.</p>
<p>The parameters for the Rule30 model are: <span style=\"font-family: Courier New;\">X = 20</span>, <span style=\"font-family: Courier New;\">Y = 10 </span>(to display 10 steps in the animation), <span style=\"font-family: Courier New;\">neighborhood = {- 1,1}</span>, <span style=\"font-family: Courier New;\">wrapped borders = 1</span>, <span style=\"font-family: Courier New;\">Tstep = 1</span>, <span style=\"font-family: Courier New;\">initial_step = 0</span>, <span style=\"font-family: Courier New;\">init_cells = 10</span>, <span style=\"font-family: Courier New;\">name = &rdquo;Rule 30&rdquo;</span>. </p>
<h4><span style=\"color: #008000\">3. Graphical Animation.</span></h4>
<p><i>CellularAutomataLib</i> supports the generation of a graphical animation during the simulation, to display the evolution of the cellular space. If desired, the graphical animation can be generated using the <span style=\"font-family: Courier New;\">Animation</span> model connected to the <span style=\"font-family: Courier New;\">CellSpace </span>(using the <span style=\"font-family: Courier New;\">CAport</span> connectors in both models). The Raylib library is used to generate the graphics of the animation.</p>
<p>The <span style=\"font-family: Courier New;\">Animation</span> model includes parameters to describe the size of the animation window (<span style=\"font-family: Courier New;\">WindowHeigth</span> and <span style=\"font-family: Courier New;\">WindowWidth</span>) and to describe the number of cells that will be displayed in each dimension (<span style=\"font-family: Courier New;\">WindowX</span>, <span style=\"font-family: Courier New;\">WindowY</span>, <span style=\"font-family: Courier New;\">WindowZ</span>). Usually, the number of displayed cells will be equal to those of the cellular space, but this model also supports the representation of aggregate states of multiple cells of the cellular space as a single cell in the animation. </p>
<p>The model also includes three functions used to manage the animation: <span style=\"font-family: Courier New;\">SetDisplayFunction</span> is used to associate a display function with the cellular space; <span style=\"font-family: Courier New;\">StepPlot</span> is the function used to actually display the state of the cells during each step; and <span style=\"font-family: Courier New;\">InitAnimation</span> that is used to initialize the animation window.</p>
<p>The animation is initialized using the parameters of the model and the <span style=\"font-family: Courier New;\">InitAnimation</span> function. The user needs to redeclare the <span style=\"font-family: Courier New;\">SetDisplayFunction</span> with his own display function to define how the state of the cells will be displayed. After that, the animation is periodically updated, following the intervals indicated by the <span style=\"font-family: Courier New;\">Tstep</span> and <span style=\"font-family: Courier New;\">intial_step</span> parameters, using the <span style=\"font-family: Courier New;\">StepPlot</span> function. Currently, only one animation window per simulation is supported.</p>
<p><br>In the rule30 model, state 0 is displayed in black, and state 1 is displayed in yellow (cf. <span style=\"font-family: Courier New;\">RDisplay</span> function in <span style=\"font-family: Courier New;\">wolfram.c</span>). The first 10 steps of simulation are shown below (the number of step is represented in the vertical axis).</p>
<p><img src=\"modelica://CellularAutomataLib/FIGS/rule30sim.png\"/> </p>
<p><b><span style=\"color: #008000;\">4. Additional Rules.</span></b> </p>
<p><i>CellularAutomataLib</i> also includes the <span style=\"font-family: Courier New;\">AdditionalRule</span> model to facilitate the application of multiple transition rules to the same cellular space. This model can be used to perform an additional transtition for the cells, simultaneously to the transition already performed by the <span style=\"font-family: Courier New;\">CellSpace</span> model, or to sequentially apply different transition rules to the same space while maintaining the evolution of the cells in the space among different transitions. </p>
<p>Note that for simultaneous transitions, the order in which the different rules are applied depends on the Modelica simulation algorithm.</p>
<p>In order to sequentially apply the additional rule, the model includes the <span style=\"font-family: Courier New;\">initial_step</span>, <span style=\"font-family: Courier New;\">Tstep</span> and <span style=\"font-family: Courier New;\">max_step</span> parameters to define the time to start the execution of the rule, the interval between steps and the maximum number of steps to be performed (these parameters are analogous to those in the <span style=\"font-family: Courier New;\">CellSpace</span> model).</p>
<p>The <span style=\"font-family: Courier New;\">AdditionalRule</span> model includes an <span style=\"font-family: Courier New;\">Initial</span> function, that can be used to re-initialize the state of the selected cells, and a <span style=\"font-family: Courier New;\">Rule</span> function, that corresponds to the transition function. Both functions need to be defined using external C code and redeclared when instantiating the model.</p>
</html>"));
    end NewModels;

    class InterfaceModels "Interfaces with other Modelica models"
      extends Modelica.Icons.Information;
      annotation (
       preferredView = "info",
        Documentation(info="<html>
<p><br><b><span style=\"font-size: 14pt; color: #008000;\">Interface models included in <i>CellularAutomataLib</span></b></i></p>
<p>The library includes five interface models that can be used to combine CA models with other CA or Modelica models. </p>
<p></span><b></span><span style=\"font-size: 10.8pt; color: #008000;\">Input Region</b></p>
<p><i>CellularAutomataLib</i> supports describing models composed of several cellular spaces. The communication between spaces is described using the Input Region model (<span style=\"font-family: Courier New;\">InputRegion</span>). </p>
<p>The combination of cellular spaces is performed by translating the state of some cells (e.g., a region) from one space as inputs for the another. The prototype of the <span style=\"font-family: Courier New;\">Rule</span> function in C includes a vector of the received inputs, in order to allow the user to manage them during the transition. Each Input Region has associated an input identifier, set using the parameter <span style=\"font-family: Courier New;\">input_id</span>, that can be used as index for the vector of inputs of the transition function. </p>
<p>The Input Region model has two interface ports: <span style=\"font-family: Courier New;\">FROM</span> and <span style=\"font-family: Courier New;\">TO</span>. These interface ports are used to connect to the involved cellular spaces. The state of the cell [i, j]|i &isin; [<span style=\"font-family: Courier New;\">XFromRange[1]</span>,<span style=\"font-family: Courier New;\">XFromRange[2]</span>], j &isin; [<span style=\"font-family: Courier New;\">YFromRange[1]</span>,<span style=\"font-family: Courier New;\">YFromRange[2]</span>], and k &isin; [<span style=\"font-family: Courier New;\">ZFromRange[1]</span>,<span style=\"font-family: Courier New;\">ZFromRange[2]</span>] in the <span style=\"font-family: Courier New;\">FROM</span> space, is translated using the <span style=\"font-family: Courier New;\">SetInput</span> function into an input for the cell [l, m, n]|l &isin; [<span style=\"font-family: Courier New;\">XTo</span>, <span style=\"font-family: Courier New;\">XTo</span> + <span style=\"font-family: Courier New;\">XFromRange[2]-XFromRange[1]</span>], m &isin; [<span style=\"font-family: Courier New;\">YTo</span>, <span style=\"font-family: Courier New;\">YTo</span> + <span style=\"font-family: Courier New;\">YFromRange</span>[2] - <span style=\"font-family: Courier New;\">YFromRange</span>[1]] , m &isin; [<span style=\"font-family: Courier New;\">ZTo</span>, ZTo + <span style=\"font-family: Courier New;\">ZFromRange</span>[2] - <span style=\"font-family: Courier New;\">ZFromRange</span>[1]] in the TO space. <span style=\"font-family: Courier New;\">XFromRange</span>, <span style=\"font-family: Courier New;\">YFromRange</span>, <span style=\"font-family: Courier New;\">ZFromRange</span>, <span style=\"font-family: Courier New;\">XTo</span>, <span style=\"font-family: Courier New;\">YTo</span>, and <span style=\"font-family: Courier New;\">ZTo</span> are parameters of the model. The communication is started at time = <span style=\"font-family: Courier New;\">comm_start</span> and is performed every <span style=\"font-family: Courier New;\">comm_rate</span> time.</p>
<p>The function <span style=\"font-family: Courier New;\">void SetInput(void* Fspace, int Fx, int Fy, int Fz, void* Tspace, int Tx, int Ty, int Tz, int input_id)</span> from the <span style=\"font-family: Courier New;\">draft.c</span> file can be used to redeclare the <span style=\"font-family: Courier New;\">SetInput</span> function of this model. </p>
<p></span><b></span><span style=\"font-size: 10.8pt; color: #008000;\">Output Region</b></p>
<p>The Output Region model can be used to observe the state of the cells in a region of the automata connected to the <span style=\"font-family: Courier New;\">FROM</span> port. The state is translated into an output <i>Real</i> signal that can be used by other Modelica models. The region of selected cells is defined by the coordinates defined by <span style=\"font-family: Courier New;\">XFromRange</span>, <span style=\"font-family: Courier New;\">YFromRange</span> and <span style=\"font-family: Courier New;\">ZFromRange</span>.</p>
<p>This model has been divided in two, the <span style=\"font-family: Courier New;\">OutputRegion</span> and the <span style=\"font-family: Courier New;\">OutputRegionM</span> models. </p>
<p><br>The <span style=\"font-family: Courier New;\">OutputRegion</span> model contains an output <i>Real</i> port, <span style=\"font-family: Courier New;\">y</span>. Depending on the value of the parameter <span style=\"font-family: Courier New;\">Output_type</span>, the state is observed in different ways:</p>
<ul>
<li>(AVERAGE): the value of <span style=\"font-family: Courier New;\">y</span> is calculated as the average value of the states of the cells in the region. </li>
<li>(MAX): the value of <span style=\"font-family: Courier New;\">y</span> is calculated as the maximum value of the states of the cells in the region. </li>
<li>(MIN): the value of <span style=\"font-family: Courier New;\">y</span> is calculated as the minimum value of the states of the cells in the region. </li>
<li>(SUM): the value of <span style=\"font-family: Courier New;\">y</span> is calculated as the sum of the values of the states of the cells in the region. </li>
</ul>
<p>The <span style=\"font-family: Courier New;\">OutputRegionM</span> model contains a matrix of output <i>Real</i> ports, <span style=\"font-family: Courier New;\">yM[XFromRange[2]-XFromRange[1]+1,&nbsp;YFromRange[2]-YFromRange[1]+1,&nbsp;ZFromRange[2]-ZFromRange[1]+1]</span>. The value of the state of the i,j,z-th cell in the space is assigned to <span style=\"font-family: Courier New;\">yM[l,m,n]</span> (where <span style=\"font-family: Courier New;\">l=1:(XFromRange[2]-XFromRange[1]+1)</span>, <span style=\"font-family: Courier New;\">m = 1:(YFromRange[2]-YFromRange[1]+1)</span> and <span style=\"font-family: Courier New;\">n=1:(ZFromRange[2]-ZFromRange[1]+1)</span>). Since the size of <span style=\"font-family: Courier New;\">yM</span> can be the size of the cellular space, and the matrix is defined in Modelica, the automatic translation of the model has to manage the definition of <span style=\"font-family: Courier New;\">yM</span> affecting the scalability and the performance of the simulation. This has to be taken into account when including the <span style=\"font-family: Courier New;\">OutputRegionM</span> model in CA models.</p>
<p>The value of the state, in both models, is translated into a <i>Real</i> value using the <i>ExtOutput</i> function, that can be redeclared using the <span style=\"font-family: Courier New;\">double ExtOutput(void* space, int x, int y, int z)</span> function included in <span style=\"font-family: Courier New;\">draft.c. </span></p>
<p></span><b></span><span style=\"font-size: 10.8pt; color: #008000;\">External Init Region</b></p>
<p>The <span style=\"font-family: Courier New;\">ExtInitRegion</span> model can be used to set the initial state of a region of cells in the space using the value of an external signal. The model has an input port, named <span style=\"font-family: Courier New;\">u</span>, where a <i>Real</i> signal is received, and a port named <span style=\"font-family: Courier New;\">TO</span> that connects to the CA. The value of <span style=\"font-family: Courier New;\">u</span> is translated, using the <i>ExtInit</i> function, into a cell state that will be used to initialize the cells in the region of the connected automaton. If <span style=\"font-family: Courier New;\">u</span> is not connected to another model its value is set to 0.</p>
<p>The region is defined by the coodirnates defined by parameters <span style=\"font-family: Courier New;\">XRange</span>, <span style=\"font-family: Courier New;\">YRange</span> and <span style=\"font-family: Courier New;\">ZRange</span>. </p>
<p>The <i>ExtInit</i> function can be redeclared using the <span style=\"font-family: Courier New;\">void ExtInit(void* space, int x, int y, int z, double value)</span> function included in <span style=\"font-family: Courier New;\">draft.c</span>. </p>
<p></span><b></span><span style=\"font-size: 10.8pt; color: #008000;\">External Input Region</b></p>
<p>Similarly to the Input Region model, the model <span style=\"font-family: Courier New;\">ExtInputRegion</span> can be used to set an input to a region of cells in the automata. In this case the input is generated using an external signal instead of the state of the cells of other automata.</p>
<p>This model receives an external <i>Real</i> input signal through port <span style=\"font-family: Courier New;\">u</span>, which is used as input for a region of cells in the automata connected to port <span style=\"font-family: Courier New;\">TO</span>. Similarly to the other interface models, the region is defined by the coordinates declared using parameters <span style=\"font-family: Courier New;\">XToRange</span>, <span style=\"font-family: Courier New;\">YToRange</span> and <span style=\"font-family: Courier New;\">ZToRange</span>.</p>
<p>The input is assigned to the position <span style=\"font-family: Courier New;\">input_id</span> of the vector of inputs, that is available for the user in the transition function. The external signal, <span style=\"font-family: Courier New;\">u</span>, can be observed using the following methods (defined by the parameter <span style=\"font-family: Courier New;\">Input_type</span>), in order to be converted into an input:</p>
<ul>
<li><i>Quantizer</i>: the input is set every time the value of the signal changes by a defined value or quantum.</li>
<li><i>Cross_UP</i>: the input is set every time the value of the signal crosses a defined threshold in the upwards direction.</li>
<li><i>Cross_DOWN</i>: the input is set every time the value of the signal crosses a defined threshold in the downwards direction.</li>
<li><i>Cross_ANY</i>: the input is set every time the value of the signal crosses a defined threshold in any direction.</li>
<li><i>Sample</i>: the input is set periodically using the <span style=\"font-family: monospace;\">sample</span> operator.</li>
</ul>
<p>The signal is translated into an input using the function <i>ExtInput</i>, that can be redeclared using the <span style=\"font-family: Courier New;\">void ExtInput(void* space,int x, int y, int z, double value, int input_id)</span> function included in <span style=\"font-family: Courier New;\">draft.c</span>. </p>
</html>"));
    end InterfaceModels;
    annotation (
     preferredView = "info",
      Documentation(info="<html>
<p><b><span style=\"font-size: 14pt; color: #008000;\">Users Guide of CellularAutomataLib</span></b> </p>
<p>This package includes the user oriented documentation aimed to faciliate the development of new CA models using CellularAutomataLib.</p>
<p>The following packages of this documentation detail how to construct new models and how to interface them with other CA and other Modelica models.</p>
<p>Each model or package of the library contains its own documentation.</p>
<p><b><span style=\"font-size: 11pt; color: #008000;\">Cellular Automata</span></b> </p>
<p>Cellular automata (CA) are a class of models initially proposed in the 1940s by John von Neumann and Stanislaw Ulam. </p>
<p>CA are dynamic, discrete-time and discrete-space models. They are represented as a grid of identical discrete volumes, named cells. The grid can be in any finite number of dimensions. The state of each single cell is finite and it is usually represented using integer numbers. The operational dynamics of the automata is described by a rule or transition function that is used to update the state of each cell at discrete time steps. This rule constitutes a function of the current state of the cell and the state of its neighbors, and defines the state of the cell for the next time step. </p>
<p>Examples of different neighborhoods in 2D are:</p>
<ul>
<li> the Moore&rsquo;s neighborhood that includes all the surrounding cells; </li>
<img src=\"modelica://CellularAutomataLib/FIGS/moore.png\"/>
<li> the von Neumann&rsquo;s neighborhood that includes the cells adjoining the four faces of one cell;</li>
<img src=\"modelica://CellularAutomataLib/FIGS/neumann.png\"/>
<li>or the extended von Neumann&rsquo;s that also includes each cell just beyond one of the four adjoining cells. </li>
<img src=\"modelica://CellularAutomataLib/FIGS/neumann-ext.png\"/> 
</ul>
<p>As it can be observed, the definition and behavior of the CA are simple. CA can provide an intuitive way of describing complex behavior using simple rules. CA may be considered as discrete idealizations in time and space of physical systems. Due to its simplicity, CA have been used to describe models of complex systems in multiple domains. CA models have been developed in areas like chemistry, economics, medicine, biology and environment, and urban architecture, among many others. </p>
<p><b><span style=\"font-size: 11pt; color: #008000;\">Structure of the library</span></b> </p>
<p>The functionality of the library to construct new CA models in contained in the <i>Components</i> package. The data structures and simulation algorihtms that implement the behavior of these components is included in the <span style=\"font-family: monospace;\">CellularAutomataLib.c</span> file. </p>
<p>The <i>Examples</i> package includes multiple examples arranged by the dimension of their cellular space. These examples demonstrate the functionality of the library and may serve to facilitate the construction of new models. The external C code required to describe new models, and the one used for the examples, is contained in the <span style=\"font-family: monospace;\">Resources.Include</span> directory of the library. </p>
</html>"));
  end Documentation;


  package Components
    class CS
      extends ExternalObject;

      function constructor
        input Integer X "Size in X";
        input Integer Y "Size in Y";
        input Integer Z "Size in Z";
        input Integer hex "flag for hexagonal 2D space";
        input Integer[:,:] neighborhood "Topology of the neighborhood";
        input Integer n1 = size(neighborhood, 1) "Number of neighbors";
        input Integer n2 = size(neighborhood, 2); // coordinates per neighbor
        input Integer n_inputs = 0 "Number of inputs";
        input Integer wrapped_borders "1 if border is wrapped, 0 otherwise";
        output CS s "Reference to the created space";
      external "C" s = CS_Create(X, Y, Z, hex, neighborhood, n1, n2, n_inputs, wrapped_borders);
        annotation (
          Include = "#include <CellularAutomataLib.c>",
          Library = "raylib",
          Documentation(info="<html>
<p>CS constructor function</p>
</html>"));
      end constructor;

      function destructor
        input CS s;

        external "C" CS_Delete(s);
        annotation (
          Include = "#include <CellularAutomataLib.c>", Documentation(info="<html>
<p>CS destructor function</p>
</html>"));
      end destructor;
    equation

      annotation (Documentation(info="<html>
<p>The CS model corresponds to the extenal object, defined in C, that is used to represent the cellular space.</p>
<p>The constructor and destructor functions are automatically executed when instatiating this class, and their C code is contained in the <span style=\"font-family: Courier New;\">cellularautomatalib.c</span> file.</p>
</html>"));
    end CS;

    partial model CellSpace
      parameter Integer X = 1 "Number of rows";
      parameter Integer Y = 1 "Number of columns";
      parameter Integer Z = 1 "Number of columns";
      parameter Integer hex = 0 "Hexagonal 2D lattice";
      parameter Integer[:, :] neighborhood = [-1,1,-1;0,1,-1;1,1,-1;-1,0,-1;0,0,-1;1,0,-1;-1,-1,-1;0,-1,-1;1,-1,-1;
                                              -1,1,0;0,1,0;1,1,0;-1,0,0;1,0,0;-1,-1,0;0,1,0;1,-1,0;
                                              -1,1,1;0,1,1;1,1,1;-1,0,1;0,0,1;1,0,1;-1,-1,1;0,-1,1;1,-1,1];
      parameter Integer n_inputs = 0 "number of inputs (from other CA or external)";
      parameter Integer wrapped_borders = 111 "mask for XYZ wrapped borders";
      parameter Real Tstep = 1 "Duration time for each step/cicle";
      parameter Real initial_step = 0 "Time for starting the cicles";
      parameter Integer max_step = Modelica.Constants.Integer_inf "Maximum number of steps";
      parameter Integer[:, :] init_cells = fill(0, 0, 3);
      parameter String name = "CA";
      Integer sumactive(start = 0);
      Real mean;

      replaceable function Default "Function to define default state for cells"
        input CS space "Reference to the space";
      end Default;

      replaceable function Initial "Initialization function"
        input CS space;
        input Integer x;
        input Integer y;
        input Integer z;
      end Initial;

      replaceable function Rule "Transition function"
        input CS space;
        output Integer out;
      end Rule;

      CS s=CS(
          X,
          Y,
          Z,
          hex,
          neighborhood,
          size(neighborhood, 1),
          size(neighborhood, 2),
          n_inputs,
          wrapped_borders);
      //Boolean init(start=false, fixed=true);
      CAport Space annotation (Placement(transformation(extent={{0,100},{20,120}}),
            iconTransformation(extent={{0,100},{20,120}})));
      Integer active;
      Integer step( start= 0);
    initial algorithm
    //when initial() and not init then
      Default(s);
      for i in 1:size(init_cells, 1) loop
        if size(init_cells,2) == 1 then
          Initial(s,init_cells[i,1],1,1);
        elseif size(init_cells,2) == 2 then
          Initial(s,init_cells[i,1],init_cells[i,2],1);
        else
          Initial(s,init_cells[i,1],init_cells[i,2],init_cells[i,3]);
        end if;
      end for;
      Modelica.Utilities.Streams.print("INIT FINISHED");
    //init := true;
    //end when;
    equation
      Space.space = s;
    algorithm
        when sample(initial_step, Tstep) and pre(step) < max_step then
        Modelica.Utilities.Streams.print("TIME ="+String(time));
        //sumactive = Rule(s);
        active := Rule(s);
        if (active == 0) then
          terminate("NO ACTIVE CELLS");
        end if;
        sumactive := pre(sumactive) + active;
        mean := if time > 0 then sumactive/(time + 1) else sumactive;
        step := pre(step)+1;
      end when;
      annotation (
        Documentation(info="<html>
<p>This model represents a multi-dimensional cellular automaton. It includes a CS model to represent the cellular space and the functions (<i>Initial</i>, <i>Default</i> and <i>Rule</i>) required to simulate the automaton.</p>
<p>The parameters of the model are:</p>
<ul>
<li><span style=\"font-family: Courier New;\">X</span>, <span style=\"font-family: Courier New;\">Y</span> and <span style=\"font-family: Courier New;\">Z</span>, that are used to define the dimensions of the space.</li>
<li><span style=\"font-family: Courier New;\">hex</span>, is used to define the geometry of each cell in 2D spaces (eigher squared or hexagonal).</li>
<li><span style=\"font-family: Courier New;\">neighborhood</span>, that defines the relative coordinates of the neighbors.</li>
<li><span style=\"font-family: Courier New;\">n_inputs</span>, sets the number of external inputs connected to the automaton.</li>
<li><span style=\"font-family: Courier New;\">wrapped_borders</span>, is a boolean mask for each dimension of the space to define the boundary condition, either open or wrapped (e.g., 101 sets X as wrapped, Y as open and Z as wrapped).</li>
<li><span style=\"font-family: Courier New;\">Tstep</span>, defines the interval between simulation steps.</li>
<li><span style=\"font-family: Courier New;\">initial_step</span>, defines the time to start the steps</li>
<li><span style=\"font-family: Courier New;\">max_step</span>, defines the maximum number of steps to be performed.</li>
<li><span style=\"font-family: Courier New;\">init_cells</span>, is used define the subset of cells that will be initialized at the beginning of the simulation.</li>
<li><span style=\"font-family: Courier New;\">name</span>, is used to identify the automaton.</li>
</ul>
<p><br>The simulation of the automaton is as follows:</p>
<ol>
<li>At the beginning of the simulation the CS constructor function is used to create the cellular space with the parameters of the model. </li>
<li>The <i>Default</i> function is used to allocate memory for the cells and set their default state. After that, the <i>Initial</i> function is used to initialize the cells with <span style=\"font-family: Courier New;\">init_cells</span>. </li>
<li>The simulation steps are periodically executed starting at time = <span style=\"font-family: Courier New;\">initial_step</span>, and with <span style=\"font-family: Courier New;\">Tstep</span> intervals. The <i>Rule</i> function is executed once for each simulation step.</li>
<li>The steps are performed until the simulation time is completed or the number of steps performed reaches <span style=\"font-family: Courier New;\">max_step</span>.</li>
</ol>
</html>"),
        Diagram(coordinateSystem(preserveAspectRatio = false, extent = {{-100, -100}, {100, 100}}, initialScale = 0.1), graphics),
        experiment(StopTime = 1000),
        __Dymola_experimentSetupOutput,
        Icon(coordinateSystem(preserveAspectRatio = false, extent = {{-100, -100}, {100, 100}}), graphics={  Rectangle(extent={{-100,60},
                  {60,-80}},                                                                                                                            lineColor={28,108,
                  200}),                                                                                                                                                          Line(points={{-80,60},
                  {-80,-80}},                                                                                                                                                                                            color={28,108,
                  200},                                                                                                                                                                                                        smooth = Smooth.None), Line(points={{-60,60},
                  {-60,-80}},                                                                                                                                                                                                        color={28,108,
                  200},                                                                                                                                                                                                        smooth = Smooth.None), Line(points={{-40,60},
                  {-40,-80}},                                                                                                                                                                                                        color={28,108,
                  200},                                                                                                                                                                                                        smooth = Smooth.None), Line(points={{-20,60},
                  {-20,-80}},                                                                                                                                                                                                        color={28,108,
                  200},                                                                                                                                                                                                        smooth = Smooth.None), Line(points={{0,60},{
                  0,-80}},                                                                                                                                                                                                        color={28,108,
                  200},                                                                                                                                                                                                        smooth = Smooth.None), Line(points={{20,60},
                  {20,-80}},                                                                                                                                                                                                        color={28,108,
                  200},                                                                                                                                                                                                        smooth = Smooth.None), Line(points={{40,60},
                  {40,-80}},                                                                                                                                                                                                        color={28,108,
                  200},                                                                                                                                                                                                        smooth = Smooth.None), Line(points = {{0, 80}, {0, -80}}, color={28,108,
                  200},                                                                                                                                                                                                        smooth = Smooth.None, origin={-20,60},  rotation = 270), Line(points = {{0, 80}, {0, -80}}, color={28,108,
                  200},                                                                                                                                                                                                        smooth = Smooth.None, origin={-20,40},  rotation = 90), Line(points = {{0, 80}, {0, -80}}, color={28,108,
                  200},                                                                                                                                                                                                        smooth = Smooth.None, origin={-20,20},  rotation = 90), Line(points = {{0, 80}, {0, -80}}, color={28,108,
                  200},                                                                                                                                                                                                        smooth = Smooth.None, origin={-20,0},   rotation = 90), Line(points = {{0, 80}, {0, -80}}, color={28,108,
                  200},                                                                                                                                                                                                        smooth = Smooth.None,                  rotation = 90,
              origin={-20,-20}),                                                                                                                                                                                                        Line(points = {{0, 80}, {0, -80}}, color={28,108,
                  200},                                                                                                                                                                                                        smooth = Smooth.None, origin={-20,-40},  rotation = 90), Line(points = {{0, 80}, {0, -80}}, color={28,108,
                  200},                                                                                                                                                                                                        smooth = Smooth.None, origin={-20,-60},  rotation = 90), Text(extent={{-80,-80},
                  {80,-120}},                                                                                                                                                                                                        lineColor={0,0,0},       textString = "%name"), Text(extent={{-100,12},
                  {60,-28}},                                                                                                                                                                                                        lineColor={0,0,0},
              textString="[%X x %Y x %Z]"),
            Line(points={{-100,60},{-80,80},{-60,100}}, color={28,108,200}),
            Line(points={{60,60},{80,80},{100,100}}, color={28,108,200}),
            Line(points={{60,-80},{80,-60},{100,-40}}, color={28,108,200}),
            Line(points={{-60,100},{100,100}}, color={28,108,200}),
            Line(points={{-80,60},{-60,80},{-40,100}}, color={28,108,200}),
            Line(points={{-60,60},{-40,80},{-20,100}}, color={28,108,200}),
            Line(points={{-40,60},{-20,80},{0,100}}, color={28,108,200}),
            Line(points={{-20,60},{0,80},{20,100}}, color={28,108,200}),
            Line(points={{0,60},{20,80},{40,100}}, color={28,108,200}),
            Line(points={{20,60},{40,80},{60,100}}, color={28,108,200}),
            Line(points={{40,60},{60,80},{80,100}}, color={28,108,200}),
            Line(points={{60,40},{80,60},{100,80}}, color={28,108,200}),
            Line(points={{60,20},{80,40},{100,60}}, color={28,108,200}),
            Line(points={{60,0},{80,20},{100,40}}, color={28,108,200}),
            Line(points={{60,-20},{80,0},{100,20}}, color={28,108,200}),
            Line(points={{60,-40},{80,-20},{100,0}}, color={28,108,200}),
            Line(points={{60,-60},{80,-40},{100,-20}}, color={28,108,200}),
            Line(points={{100,100},{100,-40}}, color={28,108,200}),
            Line(points={{70,70},{70,-70}}, color={28,108,200}),
            Line(points={{90,90},{90,-50}}, color={28,108,200}),
            Line(points={{80,80},{80,-60}}, color={28,108,200}),
            Line(points={{70,70},{-90,70}}, color={28,108,200}),
            Line(points={{80,80},{-80,80}}, color={28,108,200}),
            Line(points={{90,90},{-70,90}}, color={28,108,200})}));
    end CellSpace;

    connector CAport
      CS space;
      annotation (Documentation(info="<html>
<p>Connector used to combine multiple CA models. It is used to share a cellular space (<span style=\"font-family: Courier New;\">CellSpace</span>) with other models such as <span style=\"font-family: Courier New;\">Animation</span>, <span style=\"font-family: Courier New;\">AdditionalRule</span> or interface models. </p>
</html>"));
    end CAport;

    partial model AdditionalRule
      parameter Real Tstep = 1 "Duration time for each step/cicle";
      parameter Real initial_step = 0 "Time for starting the cicles";
      parameter Integer max_step = Modelica.Constants.Integer_inf "Maximum number of steps";
      parameter Integer[:, :] init_cells = fill(0, 0, 3);
      Integer sumactive(start = 0);
      Real mean;
      CAport Space annotation (Placement(transformation(extent={{-10,100},{10,120}}),
            iconTransformation(extent={{-10,100},{10,120}})));
      Integer active;
      Integer step( start= 0);

      replaceable function Initial "Initialization function"
        input CS space;
        input Integer x;
        input Integer y;
        input Integer z;
      end Initial;

      replaceable function Rule "Transition function"
        input CS space;
        output Integer out;
      end Rule;

    algorithm
      when time >= initial_step then
        for i in 1:size(init_cells, 1) loop
          if size(init_cells,2) == 1 then
            Initial(Space.space,init_cells[i,1],1,1);
          elseif size(init_cells,2) == 2 then
            Initial(Space.space,init_cells[i,1],init_cells[i,2],1);
          else
            Initial(Space.space,init_cells[i,1],init_cells[i,2],init_cells[i,3]);
          end if;
        end for;
      end when;
    equation
      when sample(initial_step, Tstep) and pre(step) < max_step then
        //Modelica.Utilities.Streams.print("TIME ="+String(time));
        //sumactive = Rule(s);
        active = Rule(Space.space);
        if (active == 0) then
          terminate("NO ACTIVE CELLS");
        end if;
        sumactive = pre(sumactive) + active;
        mean = if time > 0 then sumactive/(time + 1) else sumactive;
        step = pre(step)+1;
      end when;
      annotation (
        Documentation(info="<html>
<p><i><span style=\"font-family: Arial;\">CellularAutomataLib</i>&nbsp;also includes the&nbsp;</span><span style=\"font-family: Courier New;\">AdditionalRule</span><span style=\"font-family: Arial;\">&nbsp;model to facilitate the application of multiple transition rules to the same cellular space. This model can be used to perform an additional transtition for the cells, simultaneously to the transition already performed by the&nbsp;</span><span style=\"font-family: Courier New;\">CellSpace</span><span style=\"font-family: Arial;\">&nbsp;model, or to sequentially apply different transition rules to the same space while maintaining the evolution of the cells in the space among different transitions.</span></p>
<p><span style=\"font-family: Arial;\">Note that for simultaneous transitions, the order in which the different rules are applied depends on the Modelica simulation algorithm.</span></p>
<p><span style=\"font-family: Arial;\">In order to sequentially apply the additional rule, the model includes the&nbsp;</span><span style=\"font-family: Courier New;\">initial_step</span><span style=\"font-family: Arial;\">,&nbsp;</span><span style=\"font-family: Courier New;\">Tstep</span><span style=\"font-family: Arial;\">&nbsp;and&nbsp;</span><span style=\"font-family: Courier New;\">max_step</span><span style=\"font-family: Arial;\">&nbsp;parameters to define the time to start the execution of the rule, the interval between steps and the maximum number of steps to be performed (these parameters are analogous to those in the&nbsp;</span><span style=\"font-family: Courier New;\">CellSpace</span><span style=\"font-family: Arial;\">&nbsp;model).</span></p>
<p><span style=\"font-family: Arial;\">The&nbsp;</span><span style=\"font-family: Courier New;\">AdditionalRule</span><span style=\"font-family: Arial;\">&nbsp;model includes an&nbsp;</span><span style=\"font-family: Courier New;\">Initial</span><span style=\"font-family: Arial;\">&nbsp;function, that can be used to re-initialize the state of the selected cells, and a&nbsp;</span><span style=\"font-family: Courier New;\">Rule</span><span style=\"font-family: Arial;\">&nbsp;function, that corresponds to the transition function. Both functions need to be defined using external C code and redeclared when instantiating the model.</span></p>
</html>"),
        Diagram(coordinateSystem(preserveAspectRatio = false, extent = {{-100, -100}, {100, 100}}, initialScale = 0.1), graphics),
        experiment(StopTime = 1000),
        __Dymola_experimentSetupOutput,
        Icon(coordinateSystem(preserveAspectRatio = false, extent = {{-100, -100}, {100, 100}}), graphics={Text(
              extent={{-100,98},{100,-60}},
              textColor={28,108,200},
              textString="Rule"), Text(
              extent={{100,-100},{-100,-60}},
              textColor={0,0,0},
              textString="%name")}));
    end AdditionalRule;

    model Animation
      parameter Real Tstep = 1 "Duration time for each step/cicle";
      parameter Real initial_step = 0 "Time for starting the cicles";
      parameter Integer max_step = Modelica.Constants.Integer_inf "Maximum number of steps";
      parameter Integer WindowWidth = 1000 "Window width";
      parameter Integer WindowHeight = 1000 "Window height";
      parameter Integer WindowX = 1 "number of animation cells in the X axis";
      parameter Integer WindowY = 1 "number of animation cells in the Y axis";
      parameter Integer WindowZ = 1 "number of animation cells in the Z axis";
      parameter Integer Vector = 0 "0 scalar, 1 vector";
      parameter Real displayDelay = 0 "Animation update delay (in microseconds)";
      parameter String name = "CA_Animation";
      CAport Space annotation (Placement(transformation(extent={{-10,100},{10,120}}),
            iconTransformation(extent={{-10,100},{10,120}})));
      Integer step( start= 0);

      replaceable function SetDisplayFunction
        input CS space;
      end SetDisplayFunction;


      function StepPlot "Display function"
        input CS space;
        external "C" CS_Plot(space);
        annotation (Include = "#include <CellularAutomataLib.c>");
      end StepPlot;

      function InitAnimation
        input CS s;
        input Integer WindowWidth;
        input Integer WindowHeight;
        input Integer wX;
        input Integer wY;
        input Integer wZ;
        input Integer vector;
        input Real displayDelay;
        input String name;
        external "C" CS_InitAnimation(s,WindowWidth,WindowHeight,wX,wY,wZ,vector,displayDelay,name);
        annotation (Include = "#include <CellularAutomataLib.c>");
      end InitAnimation;


    initial algorithm
        InitAnimation(Space.space,WindowWidth,WindowHeight,WindowX,WindowY,WindowZ,Vector,displayDelay,name);
        SetDisplayFunction(Space.space);
    algorithm
      when sample(initial_step, Tstep) and pre(step) < max_step then
        StepPlot(Space.space);
        step :=pre(step) + 1;
      end when;
      annotation (
        Documentation(info="<html>
<p><i><span style=\"font-family: Arial;\">CellularAutomataLib</i>&nbsp;supports the generation of a graphical animation during the simulation, to display the evolution of the cellular space. If desired, the graphical animation can be generated using the&nbsp;</span><span style=\"font-family: Courier New;\">Animation</span><span style=\"font-family: Arial;\">&nbsp;model connected to the&nbsp;</span><span style=\"font-family: Courier New;\">CellSpace&nbsp;</span><span style=\"font-family: Arial;\">(using the&nbsp;</span><span style=\"font-family: Courier New;\">CAport</span><span style=\"font-family: Arial;\">&nbsp;connectors in both models). The Raylib library is used to generate the graphics of the animation.</span></p>
<p><span style=\"font-family: Arial;\">The&nbsp;</span><span style=\"font-family: Courier New;\">Animation</span><span style=\"font-family: Arial;\">&nbsp;model includes parameters to describe the size of the animation window (</span><span style=\"font-family: Courier New;\">WindowHeigth</span><span style=\"font-family: Arial;\">&nbsp;and&nbsp;</span><span style=\"font-family: Courier New;\">WindowWidth</span><span style=\"font-family: Arial;\">) and to describe the number of cells that will be displayed in each dimension (</span><span style=\"font-family: Courier New;\">WindowX</span><span style=\"font-family: Arial;\">,&nbsp;</span><span style=\"font-family: Courier New;\">WindowY</span><span style=\"font-family: Arial;\">,&nbsp;</span><span style=\"font-family: Courier New;\">WindowZ</span><span style=\"font-family: Arial;\">). Usually, the number of displayed cells will be equal to those of the cellular space, but this model also supports the representation of aggregate states of multiple cells of the cellular space as a single cell in the animation.</span></p>
<p><span style=\"font-family: Arial;\">The model also includes three functions used to manage the animation:&nbsp;</span><span style=\"font-family: Courier New;\">SetDisplayFunction</span><span style=\"font-family: Arial;\">&nbsp;is used to associate a display function with the cellular space;&nbsp;</span><span style=\"font-family: Courier New;\">StepPlot</span><span style=\"font-family: Arial;\">&nbsp;is the function used to actually display the state of the cells during each step; and&nbsp;</span><span style=\"font-family: Courier New;\">InitAnimation</span><span style=\"font-family: Arial;\">&nbsp;that is used to initialize the animation window.</span></p>
<p><span style=\"font-family: Arial;\">The animation is initialized using the parameters of the model and the&nbsp;</span><span style=\"font-family: Courier New;\">InitAnimation</span><span style=\"font-family: Arial;\">&nbsp;function. The user needs to redeclare the&nbsp;</span><span style=\"font-family: Courier New;\">SetDisplayFunction</span><span style=\"font-family: Arial;\">&nbsp;with his own display function to define how the state of the cells will be displayed. After that, the animation is periodically updated, following the intervals indicated by the&nbsp;</span><span style=\"font-family: Courier New;\">Tstep</span><span style=\"font-family: Arial;\">&nbsp;and&nbsp;</span><span style=\"font-family: Courier New;\">intial_step</span><span style=\"font-family: Arial;\">&nbsp;parameters, using the&nbsp;</span><span style=\"font-family: Courier New;\">StepPlot</span><span style=\"font-family: Arial;\">&nbsp;function. Currently, only one animation window per simulation is supported.</span></p>
</html>"),
        Diagram(coordinateSystem(preserveAspectRatio = false, extent = {{-100, -100}, {100, 100}}, initialScale = 0.1), graphics),
        experiment(StopTime = 1000),
        __Dymola_experimentSetupOutput,
        Icon(coordinateSystem(preserveAspectRatio = false, extent = {{-100, -100}, {100, 100}}), graphics={Text(
              extent={{-100,100},{100,0}},
              textColor={28,108,200},
              textString="Animation"),
                                  Text(
              extent={{100,-100},{-100,-60}},
              textColor={0,0,0},
              textString="%name"),
            Rectangle(
              extent={{-10,14},{10,-6}},
              lineColor={255,255,0},
              fillColor={0,0,0},
              fillPattern=FillPattern.Solid),
            Rectangle(
              extent={{10,-6},{30,-26}},
              lineColor={255,255,0},
              fillColor={0,0,0},
              fillPattern=FillPattern.Solid),
            Rectangle(
              extent={{-10,-26},{10,-46}},
              lineColor={255,255,0},
              fillColor={0,0,0},
              fillPattern=FillPattern.Solid),
            Rectangle(
              extent={{-30,-26},{-10,-46}},
              lineColor={255,255,0},
              fillColor={0,0,0},
              fillPattern=FillPattern.Solid),
            Rectangle(
              extent={{10,-26},{30,-46}},
              lineColor={255,255,0},
              fillColor={0,0,0},
              fillPattern=FillPattern.Solid)}));
    end Animation;

    model InputRegion
      "Input Regionregion of FROM.space CA is used as input for TO.space CA"
      parameter Integer input_id = 1 "ID for input in TO.space model";
      parameter Integer XFromRange[2] = {1,1} "FROM region in X";
      parameter Integer YFromRange[2] = {1,1} "FROM region in Y";
      parameter Integer ZFromRange[2] = {1,1} "FROM region in Z";
      parameter Integer XTo = 1 "TO region in X";
      parameter Integer YTo = 1 "TO region in Y";
      parameter Integer ZTo = 1 "TO region in Z";
      parameter Real comm_start = 0 "Time for starting communication";
      parameter Real comm_rate = 1 "Communication sampling interval";

      replaceable function SetInput "External function used to communicate CA states"
        input CS Fspace "FROM space";
        input Integer XF "FROM X";
        input Integer YF "FROM Y";
        input Integer ZF "FROM Z";
        input CS Tspace "TO space";
        input Integer XT "TO X";
        input Integer YT "TO Y";
        input Integer ZT "TO Z";
        input Integer input_id "input ID";
      end SetInput;

      input CAport FROM "Input CA model" annotation (Placement(
            transformation(extent={{-80,-10},{-60,10}}), iconTransformation(
            extent={{-10,-10},{10,10}},
            rotation=90,
            origin={-50,0})));
      input CAport TO "Output CA model" annotation (Placement(
            transformation(extent={{40,-10},{60,10}}), iconTransformation(
            extent={{-10,-10},{10,10}},
            rotation=90,
            origin={50,0})));
    protected
      Integer iTo;
      Integer jTo;
      Integer kTo;
    algorithm
      when sample(comm_start, comm_rate) then
        //2D - 2D
        iTo := XTo;
        for i in XFromRange[1]:XFromRange[2] loop
          jTo := YTo;
          for j in YFromRange[1]:YFromRange[2] loop
            kTo := ZTo;
            for k in ZFromRange[1]:ZFromRange[2] loop
              SetInput(FROM.space, i, j,k, TO.space, iTo, jTo, kTo, input_id);
              kTo := kTo + 1;
            end for;
            jTo := jTo + 1;
          end for;
          iTo := iTo + 1;
        end for;
      end when;
      annotation (
        Documentation(info="<html>
<p>CellularAutomataLib supports describing models composed of several cellular spaces. The communication between spaces is described using the Input Region model (InputRegion). </p>
<p>The combination of cellular spaces is performed by translating the state of some cells (e.g., a region) from one space as inputs for the another. The prototype of the Rule function in C includes a vector of the received inputs, in order to allow the user to manage them during the transition. Each Input Region has associated an input identifier, set using the parameter input_id, that can be used as index for the vector of inputs of the transition function. </p>
<p>The Input Region model has two interface ports: FROM and TO. These interface ports are used to connect to the involved cellular spaces. The state of the cell [i, j]|i &isin; [XFromRange[1],XFromRange[2]], j &isin; [YFromRange[1],YFromRange[2]], and k &isin; [ZFromRange[1],ZFromRange[2]] in the FROM space, is translated using the SetInput function into an input for the cell [l, m, n]|l &isin; [XTo, XTo + XFromRange[2]-XFromRange[1]], m &isin; [YTo, YTo + YFromRange[2] - YFromRange[1]] , m &isin; [ZTo, ZTo + ZFromRange[2] - ZFromRange[1]] in the TO space. XFromRange, YFromRange, ZFromRange, XTo, YTo, and ZTo are parameters of the model. The communication is started at time = comm_start and is performed every comm_rate time.</p>
<p>The function void SetInput(void* Fspace, int Fx, int Fy, int Fz, void* Tspace, int Tx, int Ty, int Tz, int input_id) from the draft.c file can be used to redeclare the SetInput function of this model. </p>
</html>"),
        Icon(coordinateSystem(preserveAspectRatio = false, extent = {{-100, -100}, {100, 100}}), graphics={  Line(points = {{-10, 60}, {-10, -60}}, color = {0, 0, 255}, smooth = Smooth.None), Line(points = {{10, 60}, {10, -60}}, color = {0, 0, 255}, smooth = Smooth.None), Line(points = {{-30, 40}, {30, 40}}, color = {0, 0, 255}, smooth = Smooth.None), Line(points = {{-30, 20}, {30, 20}}, color = {0, 0, 255}, smooth = Smooth.None), Line(points = {{-30, 0}, {30, 0}}, color = {0, 0, 255}, smooth = Smooth.None), Line(points = {{-30, -20}, {30, -20}}, color = {0, 0, 255}, smooth = Smooth.None), Line(points = {{-30, -40}, {30, -40}}, color = {0, 0, 255}, smooth = Smooth.None),                                                                                                                                                                                                        Text(extent = {{-70, -60}, {70, -100}}, lineColor = {0, 0, 255}, textString = "%name"),                                                                                                                                                                                 Polygon(points = {{-62, 30}, {-30, 0}, {-62, -30}, {-62, 30}}, lineColor = {0, 0, 255}, smooth = Smooth.None, fillColor = {0, 0, 255}, fillPattern = FillPattern.Solid), Polygon(points = {{38, 30}, {70, 0}, {38, -30}, {38, 30}}, lineColor = {0, 0, 255}, smooth = Smooth.None, fillColor = {0, 0, 255}, fillPattern = FillPattern.Solid), Text(extent = {{-10, 0}, {10, -40}}, lineColor = {0, 0, 0}, fillColor = {0, 0, 255}, fillPattern = FillPattern.Solid, textString = "%input_id")}),
        Diagram(coordinateSystem(preserveAspectRatio = false, extent = {{-100, -100}, {100, 100}}), graphics));
    end InputRegion;

    model OutputRegion
      import CellularAutomataLib.Components.*;
      parameter Integer XFromRange[2] = {1,1} "FROM region in X";
      parameter Integer YFromRange[2] = {1,1} "FROM region in Y";
      parameter Integer ZFromRange[2] = {1,1} "FROM region in Z";
      parameter Integer Output_type = 1 "Output observation method" annotation (
        choices(choice = 1 "Average", choice = 2 "Max", choice = 3 "Min", choice = 4 "Sum"));
      parameter Real output_rate "Output sampling interval";
      parameter String name "output";

      replaceable function ExtOutput "External output function"
        input CS space;
        input Integer x;
        input Integer y;
        input Integer z;
        output Real value;
      end ExtOutput;

      input CAport FROM "Reference to cellular space" annotation (Placement(
            transformation(extent={{-10,-10},{10,10}}), iconTransformation(extent={{
                -10,-10},{10,10}})));
      Modelica.Blocks.Interfaces.RealOutput y annotation (
        Placement(transformation(extent = {{50, -10}, {70, 10}}), iconTransformation(extent = {{50, -10}, {70, 10}})));
    protected
      Real sum;
      Real min;
      Real max;
      Real v;
      // Integer m,      n;
    algorithm
      when sample(0, output_rate) then
          if Output_type == 1 then
          //AVERAGE
          sum := 0;
          for i in XFromRange[1]:XFromRange[2] loop
            for j in YFromRange[1]:YFromRange[2] loop
              for k in ZFromRange[1]:ZFromRange[2] loop
                sum := sum + ExtOutput(FROM.space, i, j, k);
              end for;
            end for;
          end for;
          y := sum/(((XFromRange[2]+1)-XFromRange[1]) * ((YFromRange[2]+1)-YFromRange[1]) * ((ZFromRange[2]+1)-ZFromRange[1]));
        elseif Output_type == 2 then
          // MAX
          max := -Modelica.Constants.inf;
          for i in XFromRange[1]:XFromRange[2] loop
            for j in YFromRange[1]:YFromRange[2] loop
              for k in ZFromRange[1]:ZFromRange[2] loop
                v := ExtOutput(FROM.space, i, j, k);
                if v > max then
                  max := v;
                end if;
              end for;
            end for;
          end for;
          y := max;
        elseif Output_type == 3 then
          // MIN
          min := Modelica.Constants.inf;
          for i in XFromRange[1]:XFromRange[2] loop
            for j in YFromRange[1]:YFromRange[2] loop
              for k in ZFromRange[1]:ZFromRange[2] loop
                v := ExtOutput(FROM.space, i, j, k);
                if v < min then
                  min := v;
                end if;
              end for;
            end for;
          end for;
          y := min;
        elseif Output_type == 4 then
          //SUM
          sum := 0;
          for i in XFromRange[1]:XFromRange[2] loop
            for j in YFromRange[1]:YFromRange[2] loop
              for k in ZFromRange[1]:ZFromRange[2] loop
                sum := sum + ExtOutput(FROM.space, i, j, k);
              end for;
            end for;
          end for;
          Modelica.Utilities.Streams.print(String(time)+" : "+name+" sum = "+String(sum/6));
          y := sum;
        end if;
      end when;
      annotation (
        Documentation(info="<html>
<p>The Output Region model can be used to observe the state of the cells in a region of the automata connected to the FROM port. The state is translated into an output Real signal that can be used by other Modelica models. The region of selected cells is defined by the coordinates defined by XFromRange, YFromRange and ZFromRange.</p>
<p>This model has been divided in two, the OutputRegion and the OutputRegionM models. </p>
<p><br>The OutputRegion model contains an output Real port, y. Depending on the value of the parameter Output_type, the state is observed in different ways:</p>
<ul>
<li>(AVERAGE): the value of y is calculated as the average value of the states of the cells in the region. </li>
<li>(MAX): the value of y is calculated as the maximum value of the states of the cells in the region. </li>
<li>(MIN): the value of y is calculated as the minimum value of the states of the cells in the region. </li>
<li>(SUM): the value of y is calculated as the sum of the values of the states of the cells in the region. </li>
</ul>
<p><br>The value of the state is translated into a Real value using the ExtOutput function, that can be redeclared using the double ExtOutput(void* space, int x, int y, int z) function included in draft.c.</p>
</html>"),
        Icon(coordinateSystem(preserveAspectRatio = false, extent = {{-100, -100}, {100, 100}}), graphics={  Line(points = {{-30, 60}, {-30, -60}}, color = {0, 0, 255}, smooth = Smooth.None), Line(points = {{-10, 60}, {-10, -60}}, color = {0, 0, 255}, smooth = Smooth.None), Line(points = {{10, 60}, {10, -60}}, color = {0, 0, 255}, smooth = Smooth.None), Line(points = {{30, 60}, {30, -60}}, color = {0, 0, 255}, smooth = Smooth.None), Line(points = {{-50, 40}, {50, 40}}, color = {0, 0, 255}, smooth = Smooth.None), Line(points = {{-50, 20}, {50, 20}}, color = {0, 0, 255}, smooth = Smooth.None), Line(points = {{-50, 0}, {50, 0}}, color = {0, 0, 255}, smooth = Smooth.None), Line(points = {{-50, -20}, {50, -20}}, color = {0, 0, 255}, smooth = Smooth.None), Line(points = {{-50, -40}, {50, -40}}, color = {0, 0, 255}, smooth = Smooth.None), Text(extent = {{-50, 100}, {-10, 60}}, lineColor = {0, 0, 255}, textString = "%Cstart"), Text(extent = {{10, 100}, {50, 60}}, lineColor = {0, 0, 255}, textString = "%Cend"), Text(extent = {{-90, 60}, {-50, 20}}, lineColor = {0, 0, 255}, textString = "%Rstart"), Text(extent = {{-90, 0}, {-50, -40}}, lineColor = {0, 0, 255}, textString = "%Rend"), Text(extent = {{-70, -60}, {70, -100}}, lineColor = {0, 0, 255}, textString = "%name"), Text(extent = {{50, 46}, {70, 26}}, lineColor = {0, 0, 255}, textString = "yM"), Text(extent = {{50, -4}, {70, -24}}, lineColor = {0, 0, 255}, textString = "y")}),
        Diagram(coordinateSystem(preserveAspectRatio = false, extent = {{-100, -100}, {100, 100}}), graphics));
    end OutputRegion;

    model OutputRegionM
      parameter Integer XFromRange[2] = {1,1} "region initial column";
      parameter Integer YFromRange[2] = {1,1} "region final column";
      parameter Integer ZFromRange[2] = {1,1} "region final column";
      parameter Real output_rate "Output sampling interval";

      replaceable function ExtOutput "External output function"
        input CS space;
        input Integer x;
        input Integer y;
        input Integer z;
        output Real value;
      end ExtOutput;

      input CAport FROM "Reference to cellular space" annotation (Placement(transformation(
              extent={{-10,-10},{10,10}}), iconTransformation(extent={{-10,-10},{10,10}})));
      Modelica.Blocks.Interfaces.RealOutput yM[XFromRange[2]-XFromRange[1]+1, YFromRange[2]-YFromRange[1]+1, ZFromRange[2]-ZFromRange[1]+1] annotation (
        Placement(transformation(extent = {{50, -10}, {70, 10}}), iconTransformation(extent = {{50, -10}, {70, 10}})));
    protected
      Integer m, n, l;
    algorithm
      when sample(0, output_rate) then
        m := 1;
        n := 1;
        l := 1;
        // MATRIX
        for i in XFromRange[1]:XFromRange[2] loop
          for j in YFromRange[1]:YFromRange[2] loop
            for k in ZFromRange[1]:ZFromRange[2] loop
              yM[m, n, l] := ExtOutput(FROM.space, i, j, k);
              l := l+1;
            end for;
            l := 1;
            n := n + 1;
          end for;
          n := 1;
          m := m + 1;
        end for;
      end when;
      annotation (
        Documentation(info="<html>
<p>The Output Region model can be used to observe the state of the cells in a region of the automata connected to the FROM port. The state is translated into an output Real signal that can be used by other Modelica models. The region of selected cells is defined by the coordinates defined by XFromRange, YFromRange and ZFromRange.</p>
<p><br>Depending on the value of the parameter Output_type, the state is observed in different ways:</p>
<ul>
<li>(AVERAGE): the value of y is calculated as the average value of the states of the cells in the region. </li>
<li>(MAX): the value of y is calculated as the maximum value of the states of the cells in the region. </li>
<li>(MIN): the value of y is calculated as the minimum value of the states of the cells in the region. </li>
<li>(SUM): the value of y is calculated as the sum of the values of the states of the cells in the region. </li>
</ul>
<p><br>The OutputRegionM model contains a matrix of output Real ports, yM[XFromRange[2]-XFromRange[1]+1, YFromRange[2]-YFromRange[1]+1, ZFromRange[2]-ZFromRange[1]+1]. The value of the state of the i,j,z-th cell in the space is assigned to yM[l,m,n] (where l=1:(XFromRange[2]-XFromRange[1]+1), m = 1:(YFromRange[2]-YFromRange[1]+1) and n=1:(ZFromRange[2]-ZFromRange[1]+1)). Since the size of yM can be the size of the cellular space, and the matrix is defined in Modelica, the automatic translation of the model has to manage the definition of yM affecting the scalability and the performance of the simulation. This has to be taken into account when including the OutputRegionM model in CA models.</p>
<p>The value of the state is translated into a Real value using the ExtOutput function, that can be redeclared using the double ExtOutput(void* space, int x, int y, int z) function included in draft.c. </p>
</html>"),
        Icon(coordinateSystem(preserveAspectRatio = false, extent = {{-100, -100}, {100, 100}}), graphics={  Line(points = {{-30, 60}, {-30, -60}}, color = {0, 0, 255}, smooth = Smooth.None), Line(points = {{-10, 60}, {-10, -60}}, color = {0, 0, 255}, smooth = Smooth.None), Line(points = {{10, 60}, {10, -60}}, color = {0, 0, 255}, smooth = Smooth.None), Line(points = {{30, 60}, {30, -60}}, color = {0, 0, 255}, smooth = Smooth.None), Line(points = {{-50, 40}, {50, 40}}, color = {0, 0, 255}, smooth = Smooth.None), Line(points = {{-50, 20}, {50, 20}}, color = {0, 0, 255}, smooth = Smooth.None), Line(points = {{-50, 0}, {50, 0}}, color = {0, 0, 255}, smooth = Smooth.None), Line(points = {{-50, -20}, {50, -20}}, color = {0, 0, 255}, smooth = Smooth.None), Line(points = {{-50, -40}, {50, -40}}, color = {0, 0, 255}, smooth = Smooth.None), Text(extent = {{-50, 100}, {-10, 60}}, lineColor = {0, 0, 255}, textString = "%Cstart"), Text(extent = {{10, 100}, {50, 60}}, lineColor = {0, 0, 255}, textString = "%Cend"), Text(extent = {{-90, 60}, {-50, 20}}, lineColor = {0, 0, 255}, textString = "%Rstart"), Text(extent = {{-90, 0}, {-50, -40}}, lineColor = {0, 0, 255}, textString = "%Rend"), Text(extent = {{-70, -60}, {70, -100}}, lineColor = {0, 0, 255}, textString = "%name"), Text(extent = {{50, 46}, {70, 26}}, lineColor = {0, 0, 255}, textString = "yM"), Text(extent = {{50, -4}, {70, -24}}, lineColor = {0, 0, 255}, textString = "y")}),
        Diagram(coordinateSystem(preserveAspectRatio = false, extent = {{-100, -100}, {100, 100}}), graphics));
    end OutputRegionM;

    model ExtInitRegion
      parameter Integer XRange[2] = {1,1} "X region";
      parameter Integer YRange[2] = {1,1} "Y region";
      parameter Integer ZRange[2] = {1,1} "Z region";

      replaceable function ExtInit "External initalization function"
        input CS space;
        input Integer x;
        input Integer y;
        input Integer z;
        input Real value;
      end ExtInit;

      Modelica.Blocks.Interfaces.RealInput u "External input value" annotation (
        Placement(transformation(extent = {{-100, -20}, {-60, 20}}), iconTransformation(extent = {{-100, -20}, {-60, 20}})));
      //Boolean init(start=false, fixed=true);
      input CAport TO "Reference to the cellular space" annotation (
          Placement(transformation(extent={{20,-10},{40,10}}), iconTransformation(
              extent={{20,-10},{40,10}})));
    initial algorithm
      //when initial() and not init then
      for i in XRange[1]:XRange[2] loop
        for j in YRange[1]:YRange[2] loop
          for k in ZRange[1]:ZRange[2] loop
            ExtInit(TO.space, i, j, k, u);
          end for;
        end for;
      end for;
      //init := true;
      //end when;
    equation
      if cardinality(u) == 0 then
        u = 0;
      end if;
      annotation (
        Documentation(info="<html>
<p>The ExtInitRegion model can be used to set the initial state of a region of cells in the space using the value of an external signal. The model has an input port, named u, where a Real signal is received, and a port named TO that connects to the CA. The value of u is translated, using the ExtInit function, into a cell state that will be used to initialize the cells in the region of the connected automaton. If u is not connected to another model its value is set to 0.</p>
<p>The region is defined by the coodirnates defined by parameters XRange, YRange and ZRange. </p>
<p>The ExtInit function can be redeclared using the void ExtInit(void* space, int x, int y, int z, double value) function included in draft.c. </p>
</html>"),
        Icon(coordinateSystem(preserveAspectRatio = false, extent = {{-100, -100}, {100, 100}}), graphics={  Line(points = {{-30, 60}, {-30, -60}}, color = {0, 0, 255}, smooth = Smooth.None), Line(points = {{-10, 60}, {-10, -60}}, color = {0, 0, 255}, smooth = Smooth.None), Line(points = {{10, 60}, {10, -60}}, color = {0, 0, 255}, smooth = Smooth.None), Line(points = {{30, 60}, {30, -60}}, color = {0, 0, 255}, smooth = Smooth.None), Line(points = {{-50, 40}, {50, 40}}, color = {0, 0, 255}, smooth = Smooth.None), Line(points = {{-50, 20}, {50, 20}}, color = {0, 0, 255}, smooth = Smooth.None), Line(points = {{-50, 0}, {50, 0}}, color = {0, 0, 255}, smooth = Smooth.None), Line(points = {{-50, -20}, {50, -20}}, color = {0, 0, 255}, smooth = Smooth.None), Line(points = {{-50, -40}, {50, -40}}, color = {0, 0, 255}, smooth = Smooth.None), Text(extent = {{40, 40}, {60, 20}}, lineColor = {0, 0, 255}, textString = "%Rstart"), Text(extent = {{40, -20}, {60, -40}}, lineColor = {0, 0, 255}, textString = "%Rend"), Text(extent = {{-40, 80}, {-20, 60}}, lineColor = {0, 0, 255}, textString = "%Cstart"), Text(extent = {{20, 80}, {40, 60}}, lineColor = {0, 0, 255}, textString = "%Cend"), Text(extent = {{-70, -60}, {70, -100}}, lineColor = {0, 0, 255}, textString = "%name"), Text(extent = {{-48, 40}, {56, 20}}, lineColor = {0, 0, 0}, textString = "init")}),
        Diagram(coordinateSystem(preserveAspectRatio = false, extent = {{-100, -100}, {100, 100}}), graphics));
    end ExtInitRegion;

    model ExtInputRegion
      parameter Integer input_id = 1 "ID for input in TO.space model";
      parameter Integer XToRange[2] = {1,1} "TO region in X";
      parameter Integer YToRange[2] = {1,1} "TO region in Y";
      parameter Integer ZToRange[2] = {1,1} "TO region in Z";
      parameter Integer Input_type = 1 "Input observation method" annotation (
        choices(choice = 1 "Quantized", choice = 2 "Cross_UP", choice = 3 "Cross_DOWN", choice = 4 "Cross_ANY", choice = 5 "Sampled"));
      replaceable Real q_t = 1 "Quantum/threshold/interval value";
      parameter Real q_aux = 1e-010 "Detection value threshold";
      parameter Real start_preU = 0 "start value for preU";
      parameter Boolean start_above = false "start value for above";
      parameter Boolean start_below = false "start value for below";
      parameter Real start_sample = 0 "start sampling time";

      replaceable function ExtInput "External input function"
        input CS space;
        input Integer x;
        input Integer y;
        input Integer z;
        input Real value;
        input Integer input_id;
      end ExtInput;

      Real Y;
      Modelica.Blocks.Interfaces.RealInput u annotation (
        Placement(transformation(extent = {{-100, -20}, {-60, 20}}), iconTransformation(extent = {{-100, -20}, {-60, 20}})));
      Real preU(start = start_preU, fixed = true);
      Boolean above(start = start_above, fixed = true);
      Boolean below(start = start_below, fixed = true);
    //  Real next_t(start = start_sample, fixed = true);
      input CAport TO annotation (Placement(transformation(extent={{20,-10},
                {40,10}}), iconTransformation(extent={{20,-10},{40,10}})));
    algorithm
      // FIRST ORDER QUANTIFIER
      when (Input_type == 1) and ((u >= preU + q_t + q_aux) or (u <= preU - q_t - q_aux)) and (time > 0) then
        // Modelica.Utilities.Streams.print("Quantizer: u "+String(u));
        for i in XToRange[1]:XToRange[2] loop
          for j in YToRange[1]:YToRange[2] loop
            for k in ZToRange[1]:ZToRange[2] loop
              ExtInput(TO.space, i, j, k, u, input_id);
            end for;
          end for;
        end for;
        preU := u;
      end when;
      //CROSS UP
    algorithm
      when (Input_type == 2 or Input_type == 4) and (u > q_t) and time > 0 and pre(below) then
        Modelica.Utilities.Streams.print("Cross UP: u " + String(u));
        below := false;
        for i in XToRange[1]:XToRange[2] loop
          for j in YToRange[1]:YToRange[2] loop
            for k in ZToRange[1]:ZToRange[2] loop
              ExtInput(TO.space, i, j, k, u, input_id);
            end for;
          end for;
        end for;
      end when;
      when (Input_type == 2 or Input_type == 4) and (u < q_t) and time > 0 and not below then
        below := true;
      end when;
      //CROSS DOWN
    algorithm
      when (Input_type == 3 or Input_type == 4) and (u < q_t) and time > 0 and above then
        // Modelica.Utilities.Streams.print("CROSS DOWN: u "+String(u)+" value "+String(Value));
        above := false;
        for i in XToRange[1]:XToRange[2] loop
          for j in YToRange[1]:YToRange[2] loop
            for k in ZToRange[1]:ZToRange[2] loop
              ExtInput(TO.space, i, j, k, u, input_id);
            end for;
          end for;
        end for;
      end when;
      when (Input_type == 3 or Input_type == 4) and (u > q_t) and time > 0 and not above then
        above := true;
      end when;
    equation
      // TIME SAMPLER
    algorithm
      when (Input_type == 5 and sample(start_sample,q_t)) then
        for i in XToRange[1]:XToRange[2] loop
          for j in YToRange[1]:YToRange[2] loop
            for k in ZToRange[1]:ZToRange[2] loop
              ExtInput(TO.space, i, j, k, u, input_id);
              Y:=u;
            end for;
          end for;
        end for;
      end when;
      annotation (
        Documentation(info="<html>
<p>Similarly to the Input Region model, the model ExtInputRegion can be used to set an input to a region of cells in the automata. In this case the input is generated using an external signal instead of the state of the cells of other automata.</p>
<p>This model receives an external Real input signal through port u, which is used as input for a region of cells in the automata connected to port TO. Similarly to the other interface models, the region is defined by the coordinates declared using parameters XToRange, YToRange and ZToRange.</p>
<p>The input is assigned to the position input_id of the vector of inputs, that is available for the user in the transition function. The external signal, u, can be observed using the following methods (defined by the parameter Input_type), in order to be converted into an input:</p>
<ul>
<li>Quantizer: the input is set every time the value of the signal changes by a defined value or quantum.</li>
<li>Cross_UP: the input is set every time the value of the signal crosses a defined threshold in the upwards direction.</li>
<li>Cross_DOWN: the input is set every time the value of the signal crosses a defined threshold in the downwards direction.</li>
<li>Cross_ANY: the input is set every time the value of the signal crosses a defined threshold in any direction.</li>
<li>Sample: the input is set periodically using the sample operator.</li>
</ul>
<p>The signal is translated into an input using the function ExtInput, that can be redeclared using the void ExtInput(void* space,int x, int y, int z, double value, int input_id) function included in draft.c. </p>
</html>"),
        Icon(coordinateSystem(preserveAspectRatio = false, extent = {{-100, -100}, {100, 100}}), graphics={  Line(points = {{-30, 60}, {-30, -60}}, color = {0, 0, 255}, smooth = Smooth.None), Line(points = {{-10, 60}, {-10, -60}}, color = {0, 0, 255}, smooth = Smooth.None), Line(points = {{10, 60}, {10, -60}}, color = {0, 0, 255}, smooth = Smooth.None), Line(points = {{30, 60}, {30, -60}}, color = {0, 0, 255}, smooth = Smooth.None), Line(points = {{-50, 40}, {50, 40}}, color = {0, 0, 255}, smooth = Smooth.None), Line(points = {{-50, 20}, {50, 20}}, color = {0, 0, 255}, smooth = Smooth.None), Line(points = {{-50, 0}, {50, 0}}, color = {0, 0, 255}, smooth = Smooth.None), Line(points = {{-50, -20}, {50, -20}}, color = {0, 0, 255}, smooth = Smooth.None), Line(points = {{-50, -40}, {50, -40}}, color = {0, 0, 255}, smooth = Smooth.None),                                                                                                                                                                                                        Text(extent = {{-70, -60}, {70, -100}}, lineColor = {0, 0, 255}, textString = "%name"), Text(extent = {{-30, 40}, {-10, -40}}, lineColor = {0, 0, 0}, textString = "%input_id")}),
        Diagram(coordinateSystem(preserveAspectRatio = false, extent = {{-100, -100}, {100, 100}}), graphics));
    end ExtInputRegion;

    annotation (Documentation(info="<html>
<p>This package includes the internal components of the library, that can be used to describe new CA models.</p>
</html>"));
  end Components;

  package Examples
    package CS_1D
      function RSetDisplay "Display function for Wolfram models"
        input CellularAutomataLib.Components.CS space;

        external "C" RSetDisplay(space);
        annotation (
          Include = "#include <wolfram.c>", Documentation(info="<html>
<p>Display function for elementary CA models.</p>
</html>"));
      end RSetDisplay;

      model CSR110 "Rule 110"
        import CellularAutomataLib.Components.*;
        extends CellSpace(X = 100, neighborhood = [-1; 1], wrapped_borders = 1, Tstep = 1, initial_step = 1, init_cells = [50], name = "Rule 110",
            redeclare function Default = R110Default,
            redeclare function Initial = R110Init,
            redeclare function Rule = R110Step);

        function R110Default "Rule 110 default state function"
          input CS space;
          output Integer out;

          external "C" out = RInitDefault(space);
          annotation (
            Include = "#include <wolfram.c>");
        end R110Default;

        function R110Init "Rule 110 initalization function"
          input CS space;
          input Integer x;
          input Integer y;
          input Integer z;
          external "C" RInit(space, x, y, z);
          annotation (
            Include = "#include <wolfram.c>");
        end R110Init;

        function R110Step "Rule 110 transition function"
          input CS space;
          output Integer out;

          external "C" out = R110Step(space);
          annotation (
            Include = "#include <wolfram.c>");
        end R110Step;
        annotation (
          Documentation(info="<html>
<p>This model represents a one-dimensional cellular space following the Rule 110 as defined by Stephen Wolfram. </p>
<h4>Description</h4>
<p>This model respresents a cellular space of 100 cells, using the two adjacent cells as neighborhood and open (un-wrapped) borders. Only the cell located in the position 50 is initialized.</p><p>The new state of a cell is computed using the following table, that considers the current state of the cell (center) and its two neighbors (right and left): </p>
<table cellspacing=\"2\" cellpadding=\"0\" border=\"1\"><tr>
<td><p align=\"center\"><h4>current state (left,center,right)</h4></p></td>
<td><p>111</p></td>
<td><p>110</p></td>
<td><p>101</p></td>
<td><p>100</p></td>
<td><p>011</p></td>
<td><p>010</p></td>
<td><p>001</p></td>
<td><p>000</p></td>
</tr>
<tr>
<td><p align=\"center\"><h4>new state for center cell</h4></p></td>
<td><p>0</p></td>
<td><p>1</p></td>
<td><p>1</p></td>
<td><p>0</p></td>
<td><p>1</p></td>
<td><p>1</p></td>
<td><p>1</p></td>
<td><p>0</p></td>
</tr>
</table>
<p><br>The external functions used in the model are included in the file <span style=\"font-family: monospace;\">wolfram.c</span> </p>
</html>"),experiment(StopTime = 50),
          __Dymola_experimentSetupOutput);
      end CSR110;

      model CSR110_Animation
        CSR110 cSR110_1(initial_step=1)
          annotation (Placement(transformation(extent={{-60,0},{-40,20}})));
        Components.Animation animation(
          initial_step=0,
          WindowX=100,
          WindowY=100,
          name="Wolfram R110",
        redeclare function SetDisplayFunction = RSetDisplay)
          annotation (Placement(transformation(extent={{-18,-2},{2,18}})));
      equation
        connect(cSR110_1.Space, animation.Space) annotation (Line(points={{-49,21},
                {-50,21},{-50,28},{-8,28},{-8,19}},
                                                 color={0,0,0}));
        annotation (Icon(coordinateSystem(preserveAspectRatio=false)), Diagram(
              coordinateSystem(preserveAspectRatio=false)),
          experiment(StopTime=100, __Dymola_Algorithm="Dassl"),
          Documentation(info="<html>
<p>This model combines the CSR110 model with the Animation model to generate the graphical animation during the simulation.</p>
<p>The RSetDisplay function is used as <i>Display</i> function.</p>
</html>"));
      end CSR110_Animation;

      model CSR30 "Rule 30"
        import CellularAutomataLib.Components.*;
        extends CellSpace(X = 100, neighborhood = [-1; 1], wrapped_borders = 1, Tstep = 1, initial_step = 0, init_cells = [50], name = "Rule 30",
            redeclare function Initial = R30Init,
            redeclare function Default = R30Default,
            redeclare function Rule = R30Step);

        function R30Default "Rule 30 default state function"
          input CS space;
          output Integer out;

          external "C" out = RInitDefault(space);
          annotation (
            Include = "#include <wolfram.c>");
        end R30Default;

        function R30Init "Rule 30 initialization function"
          input CS space;
          input Integer x;
          input Integer y;
          input Integer z;

          external "C" RInit(space, x,y,z);
          annotation (
            Include = "#include <wolfram.c>");
        end R30Init;

        function R30Step "Rule 30 transition function"
          input CS space;
          output Integer out;

          external "C" out = R30Step(space);
          annotation (
            Include = "#include <wolfram.c>");
        end R30Step;
        annotation (
          Documentation(info="<html>
<p>This model represents a one-dimensional cellular space following the Rule 30 as defined by Stephen Wolfram. </p>
<h4>Description</h4>
<p>This model respresents a cellular space of 100 cells, using the two adjacent cells as neighborhood and open (un-wrapped) borders. Only the cell located in the position 50 is initialized.</p><p>The new state of a cell is computed using the following table, that considers the current state of the cell (center) and its two neighbors (right and left): </p>
<table cellspacing=\"2\" cellpadding=\"0\" border=\"1\"><tr>
<td><p align=\"center\"><h4>current state (left,center,right)</h4></p></td>
<td><p>111</p></td>
<td><p>110</p></td>
<td><p>101</p></td>
<td><p>100</p></td>
<td><p>011</p></td>
<td><p>010</p></td>
<td><p>001</p></td>
<td><p>000</p></td>
</tr>
<tr>
<td><p align=\"center\"><h4>new state for center cell</h4></p></td>
<td><p>0</p></td>
<td><p>0</p></td>
<td><p>0</p></td>
<td><p>1</p></td>
<td><p>1</p></td>
<td><p>1</p></td>
<td><p>1</p></td>
<td><p>0</p></td>
</tr>
</table>
<p><br>The external functions used in the model are included in the file <span style=\"font-family: monospace;\">wolfram.c</span> </p>
</html>"),experiment(StopTime = 50),
          __Dymola_experimentSetupOutput);
      end CSR30;

      model CSR30_Animation
        CSR30 cSR30_1(initial_step=0)
          annotation (Placement(transformation(extent={{-60,0},{-40,20}})));
        Components.Animation animation(
          initial_step=0,
          WindowX=100,
          WindowY=100,
          name="Wolfram R30",
        redeclare function SetDisplayFunction = RSetDisplay)
          annotation (Placement(transformation(extent={{-20,0},{0,20}})));
      equation
        connect(cSR30_1.Space, animation.Space) annotation (Line(points={{-49,21},
                {-50,21},{-50,28},{-10,28},{-10,21}},
                                                 color={0,0,0}));
        annotation (Icon(coordinateSystem(preserveAspectRatio=false)), Diagram(
              coordinateSystem(preserveAspectRatio=false)),
          experiment(StopTime=100, __Dymola_Algorithm="Dassl"),
          Documentation(info="<html>
<p>This model combines the CSR30 model with the Animation model to generate the graphical animation during the simulation.</p>
<p>The RSetDisplay function is used as Display function.</p>
</html>"));
      end CSR30_Animation;

      function RSetInput "Input function for Wolfram models"
        input CellularAutomataLib.Components.CS Fspace;
        input Integer XF;
        input Integer YF;
        input Integer ZF;
        input CellularAutomataLib.Components.CS Tspace;
        input Integer XT;
        input Integer YT;
        input Integer ZT;
        input Integer input_id;

        external "C" RSetInput(Fspace, XF, YF, ZF, Tspace, XT, YT, ZT, input_id);
        annotation (
          Include = "#include <wolfram.c>");
      end RSetInput;

      model input_test "Simple input test"
        CSR30 cSR30_1(
          n_inputs=0,
          wrapped_borders=0,
          name="Rule30_FROM",
          X=3,
          init_cells=[2],
          initial_step=0.1)
          annotation (Placement(transformation(extent={{-96,-18},{-38,22}})));
        CSR30 cSR30_2(
          n_inputs=1,
          wrapped_borders=0,
          name="Rule30_TO",
          X=10,
          init_cells=[2],
          initial_step=0.1)
          annotation (Placement(transformation(extent={{24,-10},{82,30}})));
         CellularAutomataLib.Components.InputRegion inputRegion(redeclare
            function SetInput =                                                               RSetInput, XFromRange = {3,3}, XTo = 8) annotation (
          Placement(transformation(extent={{-20,22},{0,42}})));
        Components.Animation animation(
          initial_step=0.1,
          WindowX=10,
          WindowY=10,
          redeclare function SetDisplayFunction = RSetDisplay)
          annotation (Placement(transformation(extent={{78,58},{98,78}})));
      equation
        connect(cSR30_1.Space, inputRegion.FROM) annotation (
          Line(points={{-64.1,24},{-64.1,32},{-15,32}},
                                                color = {0, 0, 255}, smooth = Smooth.None));
        connect(inputRegion.TO, cSR30_2.Space) annotation (
          Line(points={{-5,32},{20,32},{20,42},{55.9,42},{55.9,32}},
                                              color = {0, 0, 255}, smooth = Smooth.None));
        connect(cSR30_2.Space, animation.Space) annotation (Line(points={{55.9,32},
                {56,32},{56,79},{88,79}},
                                      color={0,0,0}));
        annotation (
          Diagram(coordinateSystem(preserveAspectRatio = false, extent = {{-100, -100}, {100, 100}})),
          experiment(StopTime = 10),
          __Dymola_experimentSetupOutput,
          Documentation(info="<html>
<p>This model is composed of two cellular spaces (two CSR30  models) that communicate using an Input Region model. </p>
<p>The size of the first space is X=3, and the second X=10. The input region translates the state of cell [3] from the first space to the cell [8] in the second space. </p>
<p>The animation model displays the evolution of the second space. </p>
</html>"));
      end input_test;

      annotation (Documentation(info="<html>
<p>Examples of 1D CA models</p>
</html>"));
    end CS_1D;

    package CS_2D
      package GameOfLife "Conway's Game of Life"
        import CellularAutomataLib.Components.*;

        function GOLSetDisplay
            input CS space;
          external "C" GOLSetDisplay(space);
          annotation (Include = "#include <gol.c>", Documentation(info="<html>
<p>This function is used to display the state of the GOL models in the animations.</p>
</html>"));
        end GOLSetDisplay;

        model CSGol_random "GOL model with random initalization"
          import CellularAutomataLib.Components.*;
          extends CellSpace(X = 100, Y = 100, neighborhood = [-1, -1; -1, 0; -1, 1; 0, -1; 0, 1; 1, -1; 1, 0; 1, 1], wrapped_borders = 11, Tstep = 1, initial_step = 0, init_cells = [X, Y], name = "Game of Life (random init)",
            redeclare function Default = GOLDefault,
            redeclare function Initial = GOLInit,
            redeclare function Rule = GOLStep);

          function GOLDefault
            input CS space;
            output Integer out;

            external "C" out = GOLDefault(space);
            annotation (
              Include = "#include \"gol.c\"", Documentation(info="<html>
<p>Default state function</p>
</html>"));
          end GOLDefault;

          function GOLInit
            input CS space;
            input Integer x;
            input Integer y;
            input Integer z;

            external "C" GOLRandomInitial(space, x, y, z);
            annotation (
              Include = "#include \"gol.c\"", Documentation(info="<html>
<p>Initial state function</p>
</html>"));
          end GOLInit;

          function GOLStep
            input CS space;
            output Integer out;

            external "C" out = GOLStep(space);
            annotation (
              Include = "#include \"gol.c\"", Documentation(info="<html>
<p>Transition function</p>
</html>"));
          end GOLStep;
          annotation (
            experiment(StopTime = 100), Documentation(info="<html>
<p>This model represents the Game of Life with a random initalization, where 50&percnt; of the cells are set initially alive.</p>
<p>The size of the space is 100x100 with wrapped borders.</p>
<p>Note that only one cell is defined in init_cells ([X,Y]). However, this can be used in the redeclared Initial function (GOLRandomInitial in gol.c) as the dimensions of the space and then initialize all the cells.</p>
</html>"));
        end CSGol_random;

        model Random_Animation
          CSGol_random cSGol_random
            annotation (Placement(transformation(extent={{-58,-10},{-38,10}})));
          Components.Animation animation(
            WindowX=100,
            WindowY=100,
            displayDelay=0,               redeclare function SetDisplayFunction =
                GOLSetDisplay)
            annotation (Placement(transformation(extent={{-22,-10},{-2,10}})));
        equation
          connect(cSGol_random.Space, animation.Space) annotation (Line(points={{-47,11},
                  {-48,11},{-48,16},{-12,16},{-12,11}}, color={0,0,0}));
          annotation (Icon(coordinateSystem(preserveAspectRatio=false)), Diagram(
                coordinateSystem(preserveAspectRatio=false)),
            Documentation(info="<html>
<p>This model includes a CSGol_random model combined with the Animation model in order to generate the graphical animation during the simulation.</p>
</html>"));
        end Random_Animation;

        model CSGol_glider "GOL model initialized with a simple glider"
          import CellularAutomataLib.Components.*;
          extends CellSpace(X = 50, Y = 50, neighborhood = [-1, -1; -1, 0; -1, 1; 0, -1; 0, 1; 1, -1; 1, 0; 1, 1], wrapped_borders = 11, Tstep = 1, initial_step = 0, name = "Game of Life (glider)", init_cells = [1, 2; 2, 3; 3, 1; 3, 2; 3, 3],
            redeclare function Initial = GOLInit,
            redeclare function Default = GOLDefault,
            redeclare function Rule = GOLStep);

          function GOLDefault
            input CS space;
            output Integer out;
            external "C" out = GOLDefault(space);
            annotation (
              Include = "#include <gol.c>", Documentation(info="<html>
<p>Default state function</p>
</html>"));
          end GOLDefault;

          function GOLStep
            input CS space;
            output Integer out;
            external "C" out = GOLStep(space);
            annotation (
              Include = "#include <gol.c>", Documentation(info="<html>
<p>Transition function</p>
</html>"));
          end GOLStep;

          function GOLInit
            input CS space;
            input Integer x;
            input Integer y;
            input Integer z;
            external "C" GOLInitial(space, x, y, z);
            annotation (
              Include = "#include <gol.c>", Documentation(info="<html>
<p>Initial state function</p>
</html>"));
          end GOLInit;
          annotation (
            experiment(StopTime = 100),
            __Dymola_experimentSetupOutput,
            Documentation(info="<html>
<p>This model represents the Game of Life with a glider initalization. A Glider is a periodic structure of cells that moves diagonally along the cellular space.</p>
<p>The size of the space is 50x50 with wrapped borders.</p>
<p>In this case, the initial cells are set to <span style=\"font-family: monospace;\">init_cells&nbsp;=&nbsp;[1,&nbsp;2;&nbsp;2,&nbsp;3;&nbsp;3,&nbsp;1;&nbsp;3,&nbsp;2;&nbsp;3,&nbsp;3]</span>, to describe the structure of the glider.</p>
</html>"));
        end CSGol_glider;

        model Glider_Animation
          CSGol_glider cSGol_glider
            annotation (Placement(transformation(extent={{-58,-20},{-38,0}})));
          Components.Animation animation(
            WindowX=50,
            WindowY=50,
            displayDelay=0,            redeclare function SetDisplayFunction =
                GOLSetDisplay)
            annotation (Placement(transformation(extent={{-20,-18},{0,2}})));
        equation
          connect(cSGol_glider.Space, animation.Space) annotation (Line(points={{-47,1},
                  {-48,1},{-48,6},{-10,6},{-10,3}}, color={0,0,0}));
          annotation (Icon(coordinateSystem(preserveAspectRatio=false)), Diagram(
                coordinateSystem(preserveAspectRatio=false)),
            Documentation(info="<html>
<p>This model includes a CSGol_glider model combined with the Animation model in order to generate the graphical animation during the simulation.</p>
</html>"));
        end Glider_Animation;

        model CSGol_row "GOL model initialized with a row"
          import CellularAutomataLib.Components.*;
          extends CellSpace(X = 20, Y = 20, neighborhood = [-1, -1; -1, 0; -1, 1; 0, -1; 0, 1; 1, -1; 1, 0; 1, 1], wrapped_borders = 00, Tstep = 1, initial_step = 0, name = "Game of Life (row)", init_cells = [10, 5; 10, 6; 10, 7; 10, 8; 10, 9; 10, 10; 10, 11; 10, 12; 10, 13; 10, 14],
            redeclare function Initial = GOLInit,
            redeclare function Default = GOLDefault,
            redeclare function Rule = GOLStep);

          function GOLDefault
            input CS space;
            output Integer out;

            external "C" out = GOLDefault(space);
            annotation (
              Include = "#include <gol.c>", Documentation(info="<html>
<p>Default state function</p>
</html>"));
          end GOLDefault;

          function GOLStep
            input CS space;
            output Integer out;

            external "C" out = GOLStep(space);
            annotation (
              Include = "#include <gol.c>", Documentation(info="<html>
<p>Transition function</p>
</html>"));
          end GOLStep;

          function GOLInit
            input CS space;
            input Integer x;
            input Integer y;
            input Integer z;

            external "C" GOLInitial(space, x, y, z);
            annotation (
              Include = "#include <gol.c>", Documentation(info="<html>
<p>Initial state function</p>
</html>"));
          end GOLInit;
          annotation (
            experiment(StopTime = 100),
            __Dymola_experimentSetupOutput,
            Documentation(info="<html>
<p>his model represents the Game of Life with a row initalization. Similarly to the glider, the row is a periodic structure of the cells but in this case it remains static in the same position of the space.</p>
<p>The size of the space is 20x20 with open borders.</p>
<p>In this case, the initial cells are set to <span style=\"font-family: monospace;\">init_cells&nbsp;=&nbsp;[10,&nbsp;5;&nbsp;10,&nbsp;6;&nbsp;10,&nbsp;7;&nbsp;10,&nbsp;8;&nbsp;10,&nbsp;9;&nbsp;10,&nbsp;10;&nbsp;10,&nbsp;11;&nbsp;10,&nbsp;12;&nbsp;10,&nbsp;13;&nbsp;10,&nbsp;14]</span>, to describe the structure of the row.</p>
</html>"));
        end CSGol_row;

        model Row_Animation
          CSGol_row cSGol_row
            annotation (Placement(transformation(extent={{-46,-20},{-26,0}})));
          Components.Animation animation(
            WindowWidth=500,
            WindowHeight=500,            WindowX=20, WindowY=20,
            displayDelay=100000,                                 redeclare
              function                                                              SetDisplayFunction =
                GOLSetDisplay)
            annotation (Placement(transformation(extent={{0,-18},{20,2}})));
        equation
          connect(cSGol_row.Space, animation.Space) annotation (Line(points={{-35,1},{-36,
                  1},{-36,10},{10,10},{10,3}}, color={0,0,0}));
          annotation (Icon(coordinateSystem(preserveAspectRatio=false)), Diagram(
                coordinateSystem(preserveAspectRatio=false)),
            Documentation(info="<html>
<p>This model includes a CSGol_row model combined with the Animation model in order to generate the graphical animation during the simulation.</p>
<p>Note that in this model the graphical animation is delayed to facilitate the observation of simulation (d<span style=\"font-family: monospace;\">isplayDelay=100000).</span></p>
</html>"));
        end Row_Animation;
        annotation (Documentation(info="<html>
<p>This package contains several examples of the &quot;Game of Life&quot; CA models described by Conway.</p>
<p>The external C code is stored in the file <span style=\"font-family: Courier New;\">gol.c</span></p>
</html>"));
      end GameOfLife;

      package Furnace "Simple furnace model"
        function FURSetDisplay
          import CellularAutomataLib.Components.*;
          input CS space;
          external "C" FURSetDisplay(space);
          annotation (
            Include = "#include <furnace.c>", Documentation(info="<html>
<p>Display function used in the graphical animations.</p>
</html>"));
        end FURSetDisplay;

        model CSFurnace "Furnace model"
          import CellularAutomataLib.Components.*;
          extends CellSpace(X = 50, Y = 50, neighborhood = [-1, -1; -1, 0; -1, 1; 0, -1; 0, 1; 1, -1; 1, 0; 1, 1],
          wrapped_borders = 0, Tstep = 1, initial_step = 0, name = "Furnace", init_cells = {{i, 1} for i in 1:X},
             redeclare function Initial = FURInit,
             redeclare function Default = FURDefault,
             redeclare function Rule = FURStep);

          function FURStep
            input CS space;
            output Integer out;

            external "C" out = FURStep(space);
            annotation (
              Include = "#include <furnace.c>", Documentation(info="<html>
<p>Transition function</p>
</html>"));
          end FURStep;

          function FURDefault
            input CS space;
            output Integer out;

            external "C" out = FURDefault(space);
            annotation (
              Include = "#include <furnace.c>", Documentation(info="<html>
<p>Default state function</p>
</html>"));
          end FURDefault;

          function FURInit
            input CS space;
            input Integer x;
            input Integer y;
            input Integer z;

            external "C" FURInitial(space,x,y,z);
            annotation (
              Include = "#include <furnace.c>", Documentation(info="<html>
<p>Initial state function</p>
</html>"));
          end FURInit;
          annotation (
            experiment(StopTime=100, __Dymola_Algorithm="Dassl"),
            __Dymola_experimentSetupOutput,
            Documentation(info="<html>
<p>Simple model for heat diffusion. Each cell stores its current temperature. Each cell temperature is updated with the average temperature of its neighbors.</p>
<p>The cellular space has a size of 50x50 and only the first row (Y=1) is initalized. The initial temperature of these cells remains constant during the simulation.</p>
</html>"));
        end CSFurnace;

        model Furnace_Animation
          CSFurnace cSFurnace
            annotation (Placement(transformation(extent={{-60,-20},{-40,0}})));
          Components.Animation animation(WindowX=50, WindowY=50, redeclare
              function                                                              SetDisplayFunction =
                FURSetDisplay)
            annotation (Placement(transformation(extent={{-20,-20},{0,0}})));
        equation
          connect(cSFurnace.Space, animation.Space) annotation (Line(points={{-49,1},{-50,
                  1},{-50,6},{-10,6},{-10,1}}, color={0,0,0}));
          annotation (Icon(coordinateSystem(preserveAspectRatio=false)), Diagram(
                coordinateSystem(preserveAspectRatio=false)),
            Documentation(info="<html>
<p>This model combines a CSFurnace model with the Animation component to generate the animation for the evolution of temperatures.</p>
</html>"));
        end Furnace_Animation;

        function FURExtInput
          import CellularAutomataLib.Components.*;
          input CS space;
          input Integer x;
          input Integer y;
          input Integer z;
          input Real value;
          input Integer input_id;

          external "C" FURExtInput(space, x, y, z, value, input_id);
          annotation (
            Include = "#include <furnace.c>", Documentation(info="<html>
<p>External input function for the furnace model.</p>
</html>"));
        end FURExtInput;

        model FurnaceExtInput
          import CellularAutomataLib.Components.*;
          CSFurnace fur(
            X=20,
            Y=20,
            n_inputs=1,
            initial_step=0)
                        annotation (Placement(visible=true, transformation(
                origin={4,-2},
                extent={{-8,30},{32,70}},
                rotation=0)));
          ExtInputRegion extinputRegion(
            XToRange={10,10},
            YToRange={10,10},
            Input_type = 5,
            q_t=1,
            start_sample=0,
            redeclare function ExtInput = FURExtInput)                                                                                                                                        annotation (
            Placement(transformation(extent = {{-54, 48}, {-2, 86}})));
          Modelica.Blocks.Sources.Constant const(k=1)   annotation (
            Placement(transformation(extent={{-88,58},{-68,78}})));
          Components.Animation animation(
            initial_step=0,
            WindowX=20,
            WindowY=20,
            redeclare function SetDisplayFunction = FURSetDisplay)
            annotation (Placement(transformation(extent={{60,40},{80,60}})));
        equation
          connect(const.y, extinputRegion.u) annotation (
            Line(points={{-67,68},{-62,68},{-62,67},{-48.8,67}},          color = {0, 0, 127}, smooth = Smooth.None));
          connect(extinputRegion.TO, fur.Space) annotation (
            Line(points={{-20.2,67},{-4.1,67},{-4.1,70},{18,70}},          color = {0, 0, 255}));
          connect(fur.Space, animation.Space) annotation (Line(points={{18,70},
                  {18,78},{70,78},{70,61}}, color={0,0,0}));
          annotation (
            Diagram(coordinateSystem(preserveAspectRatio = false, extent = {{-100, -100}, {100, 100}})),
            experiment(StopTime = 10),
            __Dymola_experimentSetupOutput,
            Documentation(info="<html>
<p>This model combines the Furnace_animation model with an external input, described using a model from the MSL (a constant signal) and an ExtInput model.</p>
<p>The temperature of the cells that receive the input is assigned with the value of the input.</p>
</html>"));
        end FurnaceExtInput;

        function FURExtOutput
          import CellularAutomataLib.Components.*;
          input CS space;
          input Integer x;
          input Integer y;
          input Integer z;
          output Real value;

          external "C" value = FUROutput(space, x, y, z);
          annotation (
            Include = "#include <furnace.c>", Documentation(info="<html>
<p>Ouput generation function</p>
</html>"));
        end FURExtOutput;

        model FurnaceOutput
          import CellularAutomataLib.Components.*;
          CSFurnace fur(X = 20, Y = 20, n_inputs = 1) annotation (
            Placement(transformation(extent = {{-38, 24}, {2, 64}})));
          ExtInputRegion inputRegion(
            XToRange={1,7},
            YToRange={20,20},                  Input_type = 5, q_t = 0.1,                                     redeclare
              function ExtInput =
                FURExtInput)                                                                                                                                     annotation (
            Placement(transformation(extent = {{-66, 52}, {-46, 72}})));
          Modelica.Blocks.Sources.Constant const(k=1)   annotation (
            Placement(transformation(extent = {{-88, 52}, {-68, 72}})));
          OutputRegion outputAVG(
            XFromRange={1,15},
            YFromRange={20,20},  output_rate = 1,                                    redeclare
              function ExtOutput =
                FURExtOutput,                                                                                                                         Output_type = 1) annotation (
            Placement(transformation(extent = {{12, 50}, {42, 74}})));
          Components.Animation animation(
            WindowX=20,
            WindowY=20,
            redeclare function SetDisplayFunction = FURSetDisplay)
            annotation (Placement(transformation(extent={{16,2},{36,22}})));
        equation
          connect(const.y, inputRegion.u) annotation (
            Line(points = {{-67, 62}, {-64, 62}}, color = {0, 0, 127}, smooth = Smooth.None));
          connect(inputRegion.TO, fur.Space) annotation (
            Line(points={{-53,62},{-34,62},{-34,66},{-16,66}},
                                                  color = {0, 0, 255}, smooth = Smooth.None));
          connect(outputAVG.FROM, fur.Space) annotation (
            Line(points={{27,62},{6,62},{6,66},{-16,66}},
                                                 color = {0, 0, 255}, smooth = Smooth.None));
          connect(animation.Space, fur.Space) annotation (Line(points={{26,23},
                  {26,46},{8,46},{8,62},{6,62},{6,66},{-16,66}}, color={0,0,0}));
          annotation (
            Diagram(coordinateSystem(preserveAspectRatio = false, extent = {{-100, -100}, {100, 100}})),
            experiment(StopTime = 10),
            __Dymola_experimentSetupOutput,
            Documentation(info="<html>
<p>In this model the FurnaceExtInput model is extended with an ExtOutput model to observe the average temperature of a region of cells.</p>
<p>However, the input region is assigned to the top row (X=1..7, Y =20). and the output is generated from the region (X = 1..15, Y = 20).</p>
</html>"));
        end FurnaceOutput;

        function FURSetInput
          import CellularAutomataLib.Components.*;
          input CS Fspace;
          input Integer XF;
          input Integer YF;
          input Integer ZF;
          input CS Tspace;
          input Integer XT;
          input Integer YT;
          input Integer ZT;
          input Integer input_id;

          external "C" FURSetInput(Fspace, XF, YF, ZF, Tspace, XT, YT, ZT, input_id);
          annotation (
            Include = "#include <furnace.c>", Documentation(info="<html>
<p>Input function.</p>
</html>"));
        end FURSetInput;

        model FurnaceInput
          import CellularAutomataLib.Components.*;
          CSFurnace fur1(X = 20, Y = 20, n_inputs = 1, name = "Furnace 1") annotation (
            Placement(transformation(extent={{-40,38},{0,78}})));
          ExtInputRegion ExternalInputRegion(
            XToRange={1,7},
            YToRange={20,20},
            Input_type=5,
            q_t=0.1,
            start_sample=0,
            redeclare function ExtInput = FURExtInput)
            annotation (Placement(transformation(extent={{-66,70},{-46,90}})));
          Modelica.Blocks.Sources.Constant const(k=1)   annotation (
            Placement(transformation(extent={{-92,70},{-72,90}})));
          CSFurnace fur2(X = 20, Y = 20, n_inputs = 1, name = "Furnace 2") annotation (
            Placement(transformation(extent={{34,-26},{74,14}})));
          InputRegion inputRegion(
            XFromRange={1,10},
            YFromRange={1,10},
            XTo=10,
            YTo=10,
            redeclare function SetInput = FURSetInput)
            annotation (Placement(transformation(extent={{20,70},{40,90}})));
          Components.Animation animation(
            WindowX=20,
            WindowY=20,
            redeclare function SetDisplayFunction = FURSetDisplay)
            annotation (Placement(transformation(extent={{0,-16},{20,4}})));
        equation
          connect(const.y, ExternalInputRegion.u) annotation (Line(
              points={{-71,80},{-64,80}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(ExternalInputRegion.TO, fur1.Space) annotation (Line(
              points={{-53,80},{-18,80}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(fur1.Space, inputRegion.FROM) annotation (Line(
              points={{-18,80},{25,80}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(inputRegion.TO, fur2.Space) annotation (Line(
              points={{35,80},{56,80},{56,16}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(animation.Space, fur2.Space) annotation (Line(points={{10,5},{
                  10,26},{56,26},{56,16}},  color={0,0,0}));
          annotation (
            Diagram(coordinateSystem(preserveAspectRatio = false, extent = {{-100, -100}, {100, 100}})),
            experiment(StopTime = 10),
            __Dymola_experimentSetupOutput,
            Documentation(info="<html>
<p>In this model two CSFurnace models are combined. The first model receives an externa input, analogous to the FurnaceExtInput model. The second furnace model receives an input from the firt furnace model, where the cells from the region (X=1..10, Y=1..10) are used as input for the equivalent region starting at (X=10, Y=10), so the region (X=10...20, Y=10..20) will receive the input.</p>
</html>"));
        end FurnaceInput;

        annotation (Documentation(info="<html>
<p>This package includes a simple model of heat diffusion. It is used to demonstrate the funtionality of the interface models included in the library.</p>
</html>"));
      end Furnace;

      package CHIPS "Heat transfer model of a chip"
        function CHIPSetDisplay
            import CellularAutomataLib.Components.*;
          input CS space;
          external "C" CHIPSetDisplay(space);
          annotation (
            Include = "#include <chip.c>", Documentation(info="<html>
<p>Display function for the chip model.</p>
</html>"));
        end CHIPSetDisplay;

        model Single_chip
          import CellularAutomataLib.Components.*;
          extends CellSpace(
            X=10,
            Y=10,
            neighborhood=[-1,0; 0,-1; 0,1; 1,0],
            wrapped_borders=0,
            Tstep=1,
            initial_step=0,
            name="chip",
            init_cells={{i,1} for i in 1:Y},
            redeclare function Initial = CHIPInit,
            redeclare function Default = CHIPDefault,
            redeclare function Rule = SCHIPStep);

          function SCHIPStep
            input CS space;
            output Integer out;

            external "C" out = SCHIPStep(space);
            annotation (
              Include = "#include <chip.c>", Documentation(info="<html>
<p>Transition function.</p>
</html>"));
          end SCHIPStep;

          function CHIPDefault
            input CS space;
            output Integer out;

            external "C" out = CHIPDefault(space);
            annotation (
              Include = "#include <chip.c>", Documentation(info="<html>
<p>Default state function</p>
</html>"));
          end CHIPDefault;

          function CHIPInit
            input CS space;
            input Integer x;
            input Integer y;
            input Integer z;

            external "C" CHIPInitial(space, x, y, z);
            annotation (
              Include = "#include <chip.c>", Documentation(info="<html>
<p>Initial state function</p>
</html>"));
          end CHIPInit;

          //,[-1,0;0,-1;0,1;1,0],
          annotation (
            experiment(StopTime = 200),
            __Dymola_experimentSetupOutput,
            Documentation(info="<html>
<p>Model for the heat diffusion on the chip. </p>
<p>The cellular space has a size of 10x10 with a Von Neumann neighborhood and open borders.</p>
</html>"));
        end Single_chip;

        model Cair
          import CellularAutomataLib.Components.*;
          extends CellSpace(X = 10, Y = 10, neighborhood = [-1, 0; 0, -1; 0, 1; 1, 0], wrapped_borders = 0, Tstep = 1, initial_step = 0,init_cells = {{1, i} for i in 1:X}, redeclare
              function Initial =                                                                                                                                                                                                         CHIPInit, redeclare
              function Default =
                CHIPDefault,                                                                                                                                                                                                        redeclare
              function Rule =                                                                                                                                                                                                         AIRStep);

          function AIRStep
            input CS space;
            output Integer out;

            external "C" out = AIRStep(space);
            annotation (
              Include = "#include <chip.c>");
          end AIRStep;

          function CHIPDefault
            input CS space;
            output Integer out;

            external "C" out = CHIPDefault(space);
            annotation (
              Include = "#include <chip.c>");
          end CHIPDefault;

          function CHIPInit
            input CS space;
            input Integer x;
            input Integer y;
            input Integer z;

            external "C" CHIPInitial(space, x, y, z);
            annotation (
              Include = "#include <chip.c>");
          end CHIPInit;
          annotation (
            experiment(StopTime = 200),
            __Dymola_experimentSetupOutput);
        end Cair;

        function CHIPExtInput
          import CellularAutomataLib.Components.*;
          input CS space;
          input Integer x;
          input Integer y;
          input Integer z;
          input Real value;
          input Integer input_id;

          external "C" CHIPExtInput(space, x, y, z, value, input_id);
          annotation (
            Include = "#include <chip.c>", Documentation(info="<html>
<p>External input function</p>
</html>"));
        end CHIPExtInput;

        function CHIPExtOutput
            import CellularAutomataLib.Components.*;
          input CS space;
          input Integer x;
          input Integer y;
          input Integer z;
          output Real value;

          external "C" value = CHIPOutput(space, x, y, z);
          annotation (
            Include = "#include <chip.c>", Documentation(info="<html>
<p>Output function</p>
</html>"));
        end CHIPExtOutput;

        function CHIPSetInput
            import CellularAutomataLib.Components.*;
          input CS Fspace;
          input Integer Fx;
          input Integer Fy;
          input Integer Fz;
          input CS Tspace;
          input Integer Tx;
          input Integer Ty;
          input Integer Tz;
          input Integer input_id;

          external "C" CHIPSetInput(Fspace, Fx, Fy, Fz, Tspace, Tx, Ty, Tz, input_id);
          annotation (
            Include = "#include <chip.c>", Documentation(info="<html>
<p>Input function</p>
</html>"));
        end CHIPSetInput;

        function CHIPExtInit
            import CellularAutomataLib.Components.*;
          input CS space;
          input Integer x;
          input Integer y;
          input Integer z;
          input Real value;

          external "C" CHIPExtInit(space, x, y, z, value);
          annotation (
            Include = "#include <chip.c>", Documentation(info="<html>
<p>External initalization function.</p>
</html>"));
        end CHIPExtInit;

        package SignalGenerators
          model Trapezoid3sin0100
            Modelica.Blocks.Sources.Trapezoid trapezoid(amplitude = ampT, rising = risingT, width = widthT, falling = fallingT, period = periodT, offset = offsetT, startTime = startTimeT) annotation (
              Placement(transformation(extent = {{-80, 50}, {-60, 70}}, rotation = 0)));
            Modelica.Blocks.Sources.Sine sine1(amplitude = ampS1, f = 1/periodS1, offset = offsetS1, startTime = startTimeS1) annotation (
              Placement(transformation(extent = {{-80, 20}, {-60, 40}}, rotation = 0)));
            Modelica.Blocks.Sources.Sine sine2(amplitude = ampS2, f = 1/periodS2, offset = offsetS2, startTime = startTimeS2) annotation (
              Placement(transformation(extent = {{-80, -10}, {-60, 10}}, rotation = 0)));
            Modelica.Blocks.Sources.Sine sine3(amplitude = ampS3, f = 1/periodS3, offset = offsetS3, startTime = startTimeS3) annotation (
              Placement(transformation(extent = {{-80, -40}, {-60, -20}}, rotation = 0)));
            parameter Real ampT = 1;
            parameter Modelica.Units.SI.Time risingT = 0;
            parameter Modelica.Units.SI.Time widthT = 0.5;
            parameter Modelica.Units.SI.Time fallingT = 0;
            parameter Modelica.Units.SI.Time periodT = 1;
            parameter Real offsetT = 0;
            parameter Modelica.Units.SI.Time startTimeT = 0;
            parameter Real ampS1 = 1;
            parameter Modelica.Units.SI.Time periodS1 = 1;
            parameter Real offsetS1 = 0;
            parameter Modelica.Units.SI.Time startTimeS1 = 0;
            parameter Real ampS2 = 1;
            parameter Modelica.Units.SI.Time periodS2 = 1;
            parameter Real offsetS2 = 0;
            parameter Modelica.Units.SI.Time startTimeS2 = 0;
            parameter Real ampS3 = 1;
            parameter Modelica.Units.SI.Time periodS3 = 1;
            parameter Real offsetS3 = 0;
            parameter Modelica.Units.SI.Time startTimeS3 = 0;
            Modelica.Blocks.Math.Add3 add31 annotation (
              Placement(transformation(extent = {{-40, 20}, {-20, 40}}, rotation = 0)));
            Modelica.Blocks.Math.Add add2 annotation (
              Placement(transformation(extent = {{0, 14}, {20, 34}}, rotation = 0)));
            Modelica.Blocks.Nonlinear.Limiter lim0100(uMax = 100, uMin = 0) annotation (
              Placement(transformation(extent = {{36, 14}, {56, 34}}, rotation = 0)));
            Modelica.Blocks.Interfaces.RealOutput y annotation (
              Placement(transformation(extent = {{60, -20}, {100, 20}}, rotation = 0)));
          equation
            connect(sine1.y, add31.u2) annotation (
              Line(points = {{-59, 30}, {-42, 30}}, color = {0, 0, 127}));
            connect(trapezoid.y, add31.u1) annotation (
              Line(points = {{-59, 60}, {-50, 60}, {-50, 38}, {-42, 38}}, color = {0, 0, 127}));
            connect(sine2.y, add31.u3) annotation (
              Line(points = {{-59, 6.10623e-16}, {-50, 6.10623e-16}, {-50, 22}, {-42, 22}}, color = {0, 0, 127}));
            connect(add31.y, add2.u1) annotation (
              Line(points = {{-19, 30}, {-2, 30}}, color = {0, 0, 127}));
            connect(add2.y, lim0100.u) annotation (
              Line(points = {{21, 24}, {34, 24}}, color = {0, 0, 127}));
            connect(lim0100.y, y) annotation (
              Line(points = {{57, 24}, {62, 24}, {62, 1.11022e-15}, {80, 1.11022e-15}}, color = {0, 0, 127}));
            connect(sine3.y, add2.u2) annotation (
              Line(points = {{-59, -30}, {-30, -30}, {-30, 18}, {-2, 18}}, color = {0, 0, 127}));
            annotation (
              Diagram(graphics),
              Icon(graphics={  Rectangle(extent = {{-100, 100}, {100, -100}}, lineColor = {0, 0, 0}, fillColor = {215, 215, 215}, fillPattern = FillPattern.Solid), Text(extent = {{-84, 54}, {50, -52}}, lineColor = {0, 0, 0}, fillColor = {215, 215, 215}, fillPattern = FillPattern.Solid, textString = "T+3S+N")}));
          end Trapezoid3sin0100;

          model Trapezoid3sinNoise0100
            Modelica.Blocks.Sources.Trapezoid trapezoid(amplitude = ampT, rising = risingT, width = widthT, falling = fallingT, period = periodT, offset = offsetT, startTime = startTimeT) annotation (
              Placement(transformation(extent = {{-80, 50}, {-60, 70}}, rotation = 0)));
            Modelica.Blocks.Sources.Sine sine1(amplitude = ampS1, f = 1/periodS1, offset = offsetS1, startTime = startTimeS1) annotation (
              Placement(transformation(extent = {{-80, 20}, {-60, 40}}, rotation = 0)));
            Modelica.Blocks.Sources.Sine sine2(amplitude = ampS2, f = 1/periodS2, offset = offsetS2, startTime = startTimeS2) annotation (
              Placement(transformation(extent = {{-80, -10}, {-60, 10}}, rotation = 0)));
            Modelica.Blocks.Sources.Sine sine3(amplitude = ampS3, f = 1/periodS3, offset = offsetS3, startTime = startTimeS3) annotation (
              Placement(transformation(extent = {{-80, -40}, {-60, -20}}, rotation = 0)));
            noiseGen noiseGen1(Ts = TsN, amp = ampN, Tf = TfN) annotation (
              Placement(transformation(extent = {{-80, -70}, {-60, -50}}, rotation = 0)));
            parameter Real ampT = 1;
            parameter Modelica.Units.SI.Time risingT = 0;
            parameter Modelica.Units.SI.Time widthT = 0.5;
            parameter Modelica.Units.SI.Time fallingT = 0;
            parameter Modelica.Units.SI.Time periodT = 1;
            parameter Real offsetT = 0;
            parameter Modelica.Units.SI.Time startTimeT = 0;
            parameter Real ampS1 = 1;
            parameter Modelica.Units.SI.Time periodS1 = 1;
            parameter Real offsetS1 = 0;
            parameter Modelica.Units.SI.Time startTimeS1 = 0;
            parameter Real ampS2 = 1;
            parameter Modelica.Units.SI.Time periodS2 = 1;
            parameter Real offsetS2 = 0;
            parameter Modelica.Units.SI.Time startTimeS2 = 0;
            parameter Real ampS3 = 1;
            parameter Modelica.Units.SI.Time periodS3 = 1;
            parameter Real offsetS3 = 0;
            parameter Modelica.Units.SI.Time startTimeS3 = 0;
            parameter Modelica.Units.SI.Time TsN = 0.1;
            parameter Real ampN = 0.01;
            parameter Real TfN = 1;
            Modelica.Blocks.Math.Add3 add31 annotation (
              Placement(transformation(extent = {{-40, 20}, {-20, 40}}, rotation = 0)));
            Modelica.Blocks.Math.Add add1 annotation (
              Placement(transformation(extent = {{-40, -46}, {-20, -26}}, rotation = 0)));
            Modelica.Blocks.Math.Add add2 annotation (
              Placement(transformation(extent = {{0, 14}, {20, 34}}, rotation = 0)));
            Modelica.Blocks.Nonlinear.Limiter lim0100(uMax = 100, uMin = 0) annotation (
              Placement(transformation(extent = {{36, 14}, {56, 34}}, rotation = 0)));
            Modelica.Blocks.Interfaces.RealOutput y annotation (
              Placement(transformation(extent = {{60, -20}, {100, 20}}, rotation = 0)));
          equation
            connect(sine1.y, add31.u2) annotation (
              Line(points = {{-59, 30}, {-42, 30}}, color = {0, 0, 127}));
            connect(trapezoid.y, add31.u1) annotation (
              Line(points = {{-59, 60}, {-50, 60}, {-50, 38}, {-42, 38}}, color = {0, 0, 127}));
            connect(sine2.y, add31.u3) annotation (
              Line(points = {{-59, 6.10623e-16}, {-50, 6.10623e-16}, {-50, 22}, {-42, 22}}, color = {0, 0, 127}));
            connect(sine3.y, add1.u1) annotation (
              Line(points = {{-59, -30}, {-42, -30}}, color = {0, 0, 127}));
            connect(noiseGen1.y, add1.u2) annotation (
              Line(points = {{-62, -60}, {-50, -60}, {-50, -42}, {-42, -42}}, color = {0, 0, 127}));
            connect(add31.y, add2.u1) annotation (
              Line(points = {{-19, 30}, {-2, 30}}, color = {0, 0, 127}));
            connect(add1.y, add2.u2) annotation (
              Line(points = {{-19, -36}, {-14, -36}, {-14, 18}, {-2, 18}}, color = {0, 0, 127}));
            connect(add2.y, lim0100.u) annotation (
              Line(points = {{21, 24}, {34, 24}}, color = {0, 0, 127}));
            connect(lim0100.y, y) annotation (
              Line(points = {{57, 24}, {62, 24}, {62, 1.11022e-15}, {80, 1.11022e-15}}, color = {0, 0, 127}));
            annotation (
              Diagram(graphics),
              Icon(graphics={  Rectangle(extent = {{-100, 100}, {100, -100}}, lineColor = {0, 0, 0}, fillColor = {215, 215, 215}, fillPattern = FillPattern.Solid), Text(extent = {{-84, 54}, {50, -52}}, lineColor = {0, 0, 0}, fillColor = {215, 215, 215}, fillPattern = FillPattern.Solid, textString = "T+3S+N")}));
          end Trapezoid3sinNoise0100;

          model noiseGen
            import Modelica.Constants.*;
            constant Real m = 2^31 - 1;
            constant Real a = 7^5;
            constant Real c = 10;
            parameter Modelica.Units.SI.Time Ts = 0.1 "sampling time";
            parameter Real amp = 0.01 "amplitude";
            parameter Real Tf = 1 "1st order filter TC";
            discrete Real x;
            discrete Real u;
            Modelica.Blocks.Interfaces.RealOutput y annotation (
              Placement(transformation(extent = {{60, -22}, {100, 22}}, rotation = 0)));
          algorithm
            when noEvent(sample(0, Ts)) then
              x := (a*x + c) - div((a*x + c), m)*m;
              u := (x/2e9 - 0.5)*amp;
              y := (Tf*y + Ts*u)/(Tf + Ts);
            end when;
            when initial() then
              x := 1.0;
            end when;
            annotation (
              Icon(graphics={  Rectangle(extent = {{-100, 100}, {100, -100}}, lineColor = {0, 0, 0}, fillColor = {215, 215, 215}, fillPattern = FillPattern.Solid), Text(extent = {{-100, 76}, {84, -62}}, lineColor = {0, 0, 0}, fillColor = {215, 215, 215}, fillPattern = FillPattern.Solid, textString = "Noise")}));
          end noiseGen;
          annotation (Documentation(info="<html>
<p>Models used to represent sources of power.</p>
</html>"));
        end SignalGenerators;

        model singlechip
          import CellularAutomataLib.Components.*;
          parameter Integer X = 10;
          parameter Integer Y = 10;
          parameter Real RATE = 0.001;
          Single_chip Chip(name = "Chip", X = X, Y = Y, init_cells = fill(0, 0, 2), wrapped_borders = 0, initial_step = 0, Tstep = RATE,                                      n_inputs = 4)                     annotation (
            Placement(transformation(extent={{8,-40},{48,-10}})));
          ExtInputRegion Pext1(
            XToRange={1,1},
            YToRange={3,3},    Input_type = 5,                                             q_t = RATE, redeclare
              function ExtInput =
                CHIPExtInput,                                                                                                                              input_id = 3) annotation (
            Placement(transformation(extent = {{-14, -28}, {6, -8}})));
          ExtInputRegion Pext2(
            XToRange={6,6},
            YToRange={6,6},                                                Input_type = 5, q_t = RATE, redeclare
              function ExtInput =
                CHIPExtInput,                                                                                                                              input_id = 4) annotation (
            Placement(transformation(extent = {{-14, -48}, {6, -28}})));
          Modelica.Blocks.Math.Gain Pg1(k = 1/100) annotation (
            Placement(transformation(extent = {{-4, -4}, {4, 4}}, rotation = 0, origin = {-20, -18})));
          SignalGenerators.Trapezoid3sin0100 lG1(ampT = 60, risingT = 1, widthT = 5, fallingT = 1, periodT = 10, offsetT = 20, ampS1 = 10, ampS2 = 5, ampS3 = 6, offsetS1 = 0, offsetS2 = 0, offsetS3 = 0, periodS1 = 4, periodS2 = 10, periodS3 = 12) annotation (
            Placement(transformation(extent = {{-7, -6}, {7, 6}}, rotation = 0, origin = {-37, -18})));
          Modelica.Blocks.Math.Gain Pg2(k = 0.5/100) annotation (
            Placement(transformation(extent = {{-4, -4}, {4, 4}}, rotation = 0, origin = {-20, -38})));
          SignalGenerators.Trapezoid3sin0100 lG2(risingT = 1, fallingT = 1, offsetS3 = 3, ampT = 50, widthT = 20, periodT = 50, offsetT = 10, ampS1 = 4, offsetS2 = 0, ampS3 = 0, offsetS1 = 0, ampS2 = 30, periodS2 = 100, periodS1 = 1, periodS3 = 30) annotation (
            Placement(transformation(extent = {{-7.5, -6.5}, {7.5, 6.5}}, rotation = 0, origin = {-36.5, -37.5})));
          ExtInitRegion InitTemp(
            XRange={1,X},
            YRange={1,Y},                            redeclare function ExtInit =
                CHIPExtInit)                                                                                 annotation (
            Placement(transformation(extent = {{-22, 2}, {-2, 22}})));
          Modelica.Blocks.Sources.Constant const(k = 20) annotation (
            Placement(transformation(extent = {{-36, 6}, {-24, 18}})));
          Cair Air(
            X=X,
            Y=Y,   name = "Air",                             init_cells = fill(0, 0, 2), Tstep = RATE,                     n_inputs = 1) annotation (
            Placement(transformation(extent = {{-24, 26}, {8, 46}})));
          InputRegion chipI2Air(
            XFromRange={1,X},
            YFromRange={1,Y},                                                     comm_rate = RATE, redeclare
              function SetInput =
                CHIPSetInput)                                                                                                                           annotation (
            Placement(transformation(extent = {{-20, -10}, {20, 10}}, rotation = 90, origin = {-42, 36})));
          InputRegion Air2Chip(
            XFromRange={1,X},
            YFromRange={1,Y},                              input_id = 1, comm_rate = RATE, redeclare
              function SetInput =
                CHIPSetInput)                                                                                                                        annotation (
            Placement(transformation(extent = {{-20, -10}, {20, 10}}, rotation = 270, origin = {30, 36})));
          OutputRegion chipTEMP(
            XFromRange={1,X},
            YFromRange={1,Y},                       Output_type = 4, output_rate = RATE, redeclare
              function ExtOutput =
                CHIPExtOutput)                                                                                                                       annotation (
            Placement(transformation(extent = {{0, 2}, {22, 22}})));
          Components.Animation animation(
            Tstep=RATE,
            WindowX=X,
            WindowY=Y, redeclare function SetDisplayFunction=CHIPSetDisplay)
            annotation (Placement(transformation(extent={{54,-30},{74,-10}})));
        equation
          connect(lG1.y, Pg1.u) annotation (
            Line(points = {{-31.4, -18}, {-24.8, -18}}, color = {0, 0, 127}, smooth = Smooth.None));
          connect(Pg1.y, Pext1.u) annotation (
            Line(points = {{-15.6, -18}, {-12, -18}}, color = {0, 0, 127}, smooth = Smooth.None));
          connect(lG2.y, Pg2.u) annotation (
            Line(points = {{-30.5, -37.5}, {-30.5, -38}, {-24.8, -38}}, color = {0, 0, 127}, smooth = Smooth.None));
          connect(Pg2.y, Pext2.u) annotation (
            Line(points = {{-15.6, -38}, {-12, -38}}, color = {0, 0, 127}, smooth = Smooth.None));
          connect(const.y, InitTemp.u) annotation (
            Line(points = {{-23.4, 12}, {-20, 12}}, color = {0, 0, 127}, smooth = Smooth.None));
          connect(chipI2Air.TO, Air.Space) annotation (
            Line(points={{-42,46},{-42,52},{-6.4,52},{-6.4,47}},      color = {0, 0, 255}, smooth = Smooth.None));
          connect(Air.Space, Air2Chip.FROM) annotation (
            Line(points={{-6.4,47},{-6.4,52},{30,52},{30,46}},      color = {0, 0, 255}, smooth = Smooth.None));
          connect(chipI2Air.FROM, Chip.Space) annotation (
            Line(points={{-42,26},{-42,0},{30,0},{30,-8.5}},           color = {0, 0, 255}, smooth = Smooth.None));
          connect(Air2Chip.TO, Chip.Space) annotation (
            Line(points={{30,26},{30,-8.5}},                         color = {0, 0, 255}, smooth = Smooth.None));
          connect(InitTemp.TO, Chip.Space) annotation (
            Line(points={{-9,12},{0,12},{0,0},{30,0},{30,-8.5}},             color = {0, 0, 255}, smooth = Smooth.None));
          connect(chipTEMP.FROM, Chip.Space) annotation (
            Line(points={{11,12},{0,12},{0,0},{30,0},{30,-8.5}},             color = {0, 0, 255}, smooth = Smooth.None));
          connect(Pext1.TO, Chip.Space) annotation (
            Line(points={{-1,-18},{4,-18},{4,-6},{30,-6},{30,-8.5}},             color = {0, 0, 255}, smooth = Smooth.None));
          connect(Pext2.TO, Chip.Space) annotation (
            Line(points={{-1,-38},{4,-38},{4,-6},{30,-6},{30,-8.5}},             color = {0, 0, 255}, smooth = Smooth.None));
          connect(Chip.Space, animation.Space) annotation (Line(points={{30,-8.5},
                  {30,0},{64,0},{64,-9}},
                                    color={0,0,0}));
          annotation (
            Diagram(coordinateSystem(preserveAspectRatio = false, extent = {{-100, -100}, {100, 100}})),
            experiment(StopTime = 10),
            __Dymola_experimentSetupOutput,
            Icon(coordinateSystem(extent = {{-100, -100}, {100, 100}})),
            Documentation(info="<html>
<p>This model combines a Single_chip and a Cair models to describe the heat diffusion on the chip and the surrounding air. The chip receives external inputs as sources of power. The chip and the air are connected using Input Region models. The output region model is used to observe the evolution of the temperature together with an animation model.</p>
</html>"));
        end singlechip;
        annotation (Documentation(info="<html>
<p>This package includes a more complex model of temperature diffusion, which is generated from different points in the surface of a chip.</p>
<p>External functions are stored in the <span style=\"font-family: monospace;\">chip.c</span> file.</p>
</html>"));
      end CHIPS;

      package Epidemics
        function SetDisplay
            import CellularAutomataLib.Components.*;
          input CS space;
          external "C" SetDisplay(space);
          annotation (
            Include = "#include <epidemics.c>", Documentation(info="<html>
<p>Display function</p>
</html>"));
        end SetDisplay;

        model EpidemicsCA
          import CellularAutomataLib.Components.*;
          extends CellSpace(X = 50, Y = 50, neighborhood = [-1, -1; -1, 0; -1, 1; 0, -1; 0, 1; 1, -1; 1, 0; 1, 1], n_inputs = 0, wrapped_borders = 0, Tstep = 1, initial_step = 0, init_cells = {{25, 25}}, name = "Chagas", redeclare
              function Rule =                                                                                                                                                                                                         ERule, redeclare
              function Default =                                                                                                                                                                                                         EDefault, redeclare
              function Initial =                                                                                                                                                                                                         EInitial);
          //[-1, 0; 0, -1; 0, 1; 1, 0],

          function ERule "Transition function"
            input CS space;
            output Integer out;

            external "C" out = Step(space);
            annotation (
              Include = "#include <epidemics.c>", Documentation(info="<html>
<p>Transition function</p>
</html>"));
          end ERule;

          function EDefault "Default state function"
            input CS space;
            output Integer out;

            external "C" out = EDefault(space);
            annotation (
              Include = "#include <epidemics.c>", Documentation(info="<html>
<p>Default state function</p>
</html>"));
          end EDefault;

          function EInitial "Initialization function"
            input CS space;
            input Integer x;
            input Integer y;
            input Integer z;

            external "C" Ini(space, x, y,z);
            annotation (
              Include = "#include <epidemics.c>", Documentation(info="<html>
<p>Initial state function</p>
</html>"));
          end EInitial;
          annotation (Documentation(info="<html>
<p>This model is used to represent the space where the epidemic is spread. The size of the cellular space is 50x50 with open borders. The cell in the  center of the space ([25,25]) is initially set as infected to start the epidemic.</p>
</html>"));
        end EpidemicsCA;

        model Epidemics500
          EpidemicsCA epidemicsCA(                name = "Epidemics", X = 500, Y = 500, init_cells = {{250, 250}})                    annotation (
            Placement(transformation(extent = {{-24, -4}, {20, 40}})));
          Components.Animation animation(WindowX=500, WindowY=500, redeclare
              function                                                                SetDisplayFunction=SetDisplay)
            annotation (Placement(transformation(extent={{-80,20},{-60,40}})));
        equation
          connect(epidemicsCA.Space, animation.Space) annotation (Line(points={{0.2,42.2},
                  {0.2,50},{-70,50},{-70,41}}, color={0,0,0}));
          annotation (
            Diagram(coordinateSystem(preserveAspectRatio = false, extent = {{-100, -100}, {100, 100}})),
            experiment(StopTime = 100),
            __Dymola_experimentSetupOutput,
            Documentation(info="<html>
<p>Model that includes the EpidemicsCA with an Animation model, using space of 500x500 cells.</p>
</html>"));
        end Epidemics500;

        function ExtOutputS
          import CellularAutomataLib.Components.*;
          input CS space;
          input Integer x;
          input Integer y;
          input Integer z;
          output Real value;

          external "C" value = OutputS(space, x, y, z);
          annotation (
            Include = "#include <epidemics.c>", Documentation(info="<html>
<p>Output function for the S value</p>
</html>"));
        end ExtOutputS;

        function ExtOutputI
          import CellularAutomataLib.Components.*;
          input CS space;
          input Integer x;
          input Integer y;
          input Integer z;
          output Real value;

          external "C" value = OutputI(space, x, y, z);
          annotation (
            Include = "#include <epidemics.c>", Documentation(info="<html>
<p>Output function for the I value</p>
</html>"));
        end ExtOutputI;

        function ExtOutputR
          import CellularAutomataLib.Components.*;
          input CS space;
          input Integer x;
          input Integer y;
          input Integer z;
          output Real value;

          external "C" value = OutputR(space, x, y, z);
          annotation (
            Include = "#include <epidemics.c>", Documentation(info="<html>
<p>Output function for the R value.</p>
</html>"));
        end ExtOutputR;

        model Epidemics50
          import CellularAutomataLib.Components.*;
          EpidemicsCA epidemicsCA(                name = "Epidemics", X = 50, Y = 50, init_cells = {{25, 25}})                        annotation (
            Placement(transformation(extent = {{-24, -2}, {20, 42}})));
          OutputRegion S(
            XFromRange={1,50},
            YFromRange={1,50},
            Output_type=4,                output_rate = 1, redeclare function
              ExtOutput =                                                                         ExtOutputS)
                                                                                                                                    annotation (
            Placement(transformation(extent = {{40, 30}, {60, 50}})));
          OutputRegion I(
            XFromRange={1,50},
            YFromRange={1,50},
            Output_type=4,                output_rate = 1, redeclare function
              ExtOutput =                                                                         ExtOutputI)
                                                                                                                                    annotation (
            Placement(transformation(extent = {{40, 12}, {60, 32}})));
          OutputRegion R(
            XFromRange={1,50},
            YFromRange={1,50},
            Output_type=4,                output_rate = 1, redeclare function
              ExtOutput =                                                                         ExtOutputR)
                                                                                                                                    annotation (
            Placement(transformation(extent = {{40, -6}, {60, 14}})));
          Components.Animation animation(
            WindowX=50,
            WindowY=50,
            displayDelay=5000,
            redeclare function SetDisplayFunction = SetDisplay)
            annotation (Placement(transformation(extent={{-60,18},{-40,38}})));
        equation
          connect(epidemicsCA.Space, S.FROM) annotation (
            Line(points={{0.2,44.2},{24,44.2},{24,40},{50,40}},         color = {0, 0, 255}, smooth = Smooth.None));
          connect(I.FROM, epidemicsCA.Space) annotation (
            Line(points={{50,22},{24,22},{24,44.2},{0.2,44.2}},         color = {0, 0, 255}, smooth = Smooth.None));
          connect(R.FROM, epidemicsCA.Space) annotation (
            Line(points={{50,4},{24,4},{24,44.2},{0.2,44.2}},         color = {0, 0, 255}, smooth = Smooth.None));
          connect(animation.Space, epidemicsCA.Space) annotation (Line(points={
                  {-50,39},{-50,54},{0.2,54},{0.2,44.2}}, color={0,0,0}));
          annotation (
            Diagram(coordinateSystem(preserveAspectRatio = false, extent = {{-100, -100}, {100, 100}})),
            experiment(StopTime = 30),
            __Dymola_experimentSetupOutput,
            Documentation(info="<html>
<p>Epidemic model that includes the animation and three output region models to observe the variation of S, I and R.</p>
</html>"));
        end Epidemics50;
        annotation (Documentation(info="<html>
<p>This package contains models used to describe the spread of epidemics following a SIR approach.</p>
<p>External code can be found in <span style=\"font-family: monospace;\">epidemics.c</span></p>
</html>"));
      end Epidemics;

      package Forest
        function SetDisplay
            import CellularAutomataLib.Components.*;
          input CS space;
          external "C" SetDisplay(space);
          annotation (
            Include = "#include <forest.c>", Documentation(info="<html>
<p>Display function</p>
</html>"));
        end SetDisplay;

        model ForestCA
          import CellularAutomataLib.Components.*;
          extends CellSpace(X = 30, Y = 30, neighborhood = [-1, -1; -1, 0; -1, 1; 0, 1; 1, 1; 1, 0; 1, -1; 0, -1], n_inputs = 0, wrapped_borders = 0, Tstep = 1, initial_step = 0, init_cells = [X, Y], name = "ForestCA",
            redeclare function Rule = FRule,
            redeclare function Default = FDefault,
            redeclare function Initial = FInitial);
          //[-1, 0; 0, -1; 0, 1; 1, 0],

          function FRule "Transition function"
            input CS space;
            output Integer out;

            external "C" out = Step(space);
            annotation (
              Include = "#include <forest.c>", Documentation(info="<html>
<p>Transition function</p>
</html>"));
          end FRule;

          function FDefault
            input CS space;
            output Integer out;

            external "C" out = FDefault(space);
            annotation (
              Include = "#include <forest.c>",
              Library = "m",
              Documentation(info="<html>
<p>Default state function</p>
</html>"));
          end FDefault;

          function FInitial "Initialization function"
            input CS space;
            input Integer x;
            input Integer y;
            input Integer z;

            external "C" Ini(space, x, y, z);
            annotation (
              Include = "#include <forest.c>", Documentation(info="<html>
<p>Initial state function</p>
</html>"));
          end FInitial;
          annotation (
            experiment(StopTime = 300),
            __Dymola_experimentSetupOutput,
            Documentation(info="<html>
<p>Forest fire spread model. The model behavior is computed using the Rothermel model from an external C file. Fire spread also depends on wind direction and speed, and firefighting actions (pouring water). See transition function for details.</p>
<p>The fire is initally active in a single cell.</p>
</html>"));
        end ForestCA;

        function ExtInput
          import CellularAutomataLib.Components.*;
          input CS space;
          input Integer x;
          input Integer y;
          input Integer z;
          input Real value;
          input Integer input_id;

          external "C" ExtInput(space, x, y, z, value, input_id);
          annotation (
            Include = "#include <forest.c>", Documentation(info="<html>
<p>External input function</p>
</html>"));
        end ExtInput;

        function ExtOutput
          import CellularAutomataLib.Components.*;
          input CS space;
          input Integer x;
          input Integer y;
          input Integer z;
          output Real value;

          external "C" value = Output(space, x, y, z);
          annotation (
            Include = "#include <forest.c>", Documentation(info="<html>
<p>Output function.</p>
</html>"));
        end ExtOutput;

        model ForestFire1000
          ForestCA Forest(name = "Forest", n_inputs = 0, wrapped_borders = 3, X = 1000, Y = 1000,                     init_cells = [900, 500]) annotation (
            Placement(transformation(extent = {{-20, -20}, {20, 20}})));
          Components.Animation animation(
            WindowX=1000,
            WindowY=1000,
            redeclare function SetDisplayFunction = SetDisplay)
            annotation (Placement(transformation(extent={{38,10},{58,30}})));
        equation
          connect(Forest.Space, animation.Space)
            annotation (Line(points={{2,22},{2,31},{48,31}}, color={0,0,0}));
          annotation (
            Diagram(coordinateSystem(preserveAspectRatio = false, extent = {{-100, -100}, {100, 100}})),
            experiment(StopTime = 120),
            __Dymola_experimentSetupOutput,
            Icon(coordinateSystem(extent = {{-100, -100}, {100, 100}})),
            Documentation(info="<html>
<p>This model is composed of a ForestCA model and an animation model. The size of the cellular space is set to 1000x1000. The parameters of the fire spread (wind and firefighter actions) remain constant.</p>
</html>"));
        end ForestFire1000;

        model ForestFire500
          import CellularAutomataLib.Components.*;
          ForestCA Forest(name = "Forest", n_inputs = 3, init_cells = [400, 250], X = 500, Y = 500)                     annotation (
            Placement(transformation(extent = {{-20, -20}, {20, 20}})));
          ExtInputRegion Water(
            XToRange={250,500},
            YToRange={250,500},Input_type = 1, redeclare function ExtInput = ExtInput, input_id = 1, q_t = 0.5)                                                     annotation (
            Placement(transformation(extent = {{-62, 16}, {-18, 56}})));
          Modelica.Blocks.Sources.Step water(startTime = 70) annotation (
            Placement(transformation(extent = {{-94, 26}, {-74, 46}})));
          ExtInputRegion WindDir(
            XToRange={1,500},
            YToRange={1,500},                          Input_type = 1, redeclare
              function ExtInput =                                                                            ExtInput, input_id = 2)                         annotation (
            Placement(transformation(extent = {{-62, -20}, {-20, 20}})));
          Modelica.Blocks.Sources.Step winddir(startTime = 50, height = 270) annotation (
            Placement(transformation(extent = {{-94, -10}, {-74, 10}})));
          ExtInputRegion WindSpeed(
            XToRange={1,500},
            YToRange={1,500},                            Input_type = 1, redeclare
              function ExtInput =                                                                              ExtInput, input_id = 3)                         annotation (
            Placement(transformation(extent = {{-62, -56}, {-20, -16}})));
          Modelica.Blocks.Sources.Step windspeed(startTime = 50, height = 3) annotation (
            Placement(transformation(extent = {{-94, -46}, {-74, -26}})));
          OutputRegion FireSize(
            XFromRange={1,500},
            YFromRange={1,500}, Output_type = 5, redeclare function ExtOutput =         ExtOutput, output_rate = 1)                         annotation (
            Placement(transformation(extent = {{24, -16}, {56, 16}})));
          Components.Animation animation(
            WindowX=500,
            WindowY=500,
            redeclare function SetDisplayFunction = SetDisplay)
            annotation (Placement(transformation(extent={{28,36},{48,56}})));
        equation
          connect(Water.TO, Forest.Space) annotation (
            Line(points={{-33.4,36},{-20,36},{-20,22},{2,22}},                    color = {0, 0, 255}, smooth = Smooth.None));
          connect(water.y, Water.u) annotation (
            Line(points = {{-73, 36}, {-57.6, 36}}, color = {0, 0, 127}, smooth = Smooth.None));
          connect(winddir.y, WindDir.u) annotation (
            Line(points = {{-73, 0}, {-57.8, 0}}, color = {0, 0, 127}, smooth = Smooth.None));
          connect(windspeed.y, WindSpeed.u) annotation (
            Line(points = {{-73, -36}, {-57.8, -36}}, color = {0, 0, 127}, smooth = Smooth.None));
          connect(WindDir.TO, Forest.Space) annotation (
            Line(points={{-34.7,0},{-20,0},{-20,22},{2,22}},                    color = {0, 0, 255}, smooth = Smooth.None));
          connect(WindSpeed.TO, Forest.Space) annotation (
            Line(points={{-34.7,-36},{-20,-36},{-20,22},{2,22}},                    color = {0, 0, 255}, smooth = Smooth.None));
          connect(FireSize.FROM, Forest.Space) annotation (
            Line(points={{40,4.44089e-16},{40,22},{2,22}},        color = {0, 0, 255}, smooth = Smooth.None));
          connect(Forest.Space, animation.Space) annotation (Line(points={{2,22},
                  {-2,22},{-2,57},{38,57}}, color={0,0,0}));
          annotation (
            Diagram(coordinateSystem(preserveAspectRatio = false, extent = {{-100, -100}, {100, 100}})),
            experiment(StopTime = 120),
            __Dymola_experimentSetupOutput,
            Icon(coordinateSystem(extent = {{-100, -100}, {100, 100}})),
            Documentation(info="<html>
<p>This model is composed of a ForestCA model combined with three external input region models used to change the direction and speed of the wind and the actions from the firefighters. Also, the model includes an output region model to observe the size of the fire and an animation model.</p>
<p>The size of the cellular space is 500x500, and the fire is started at cell [400,250].</p>
</html>"));
        end ForestFire500;

        annotation (Documentation(info="<html>
<p>Package that contains a forest fire spread model, using an external C model (Rothermel) combined with the CA transistion function.</p>
</html>"));
      end Forest;

      package C17
        model eqmodel
          parameter Real r = 0.00006 "infection rate";
          parameter Real a = 0.2 "recovery rate";
          Real S(fixed = true, start = 16000) "susceptible";
          Real I(fixed = true, start = 100) "infected";
          Real R(fixed = true, start = 0) "recovered";
        equation
          der(S) = -r*S*I;
          der(I) = r*S*I - a*I;
          der(R) = a*I;
          annotation (
            experiment(StopTime = 50),
            __Dymola_experimentSetupOutput,
            Documentation(info="<html>
<p>SIR differential equation model</p>
</html>"));
        end eqmodel;

        model diffeqmodel
          parameter Real r = 0.00006 "infection rate";
          parameter Real a = 0.2 "recovery rate";
          discrete Real S(fixed = true, start = 16000) "susceptible";
          discrete Real I(fixed = true, start = 100) "infected";
          discrete Real R(fixed = true, start = 0) "recovered";
        equation
          when sample(0, 1) then
            S = pre(S) - r*pre(S)*pre(I);
            I = pre(I) + r*pre(S)*pre(I) - a*pre(I);
            R = pre(R) + a*pre(I);
          end when;
          annotation (
            experiment(StopTime = 50),
            __Dymola_experimentSetupOutput,
            Documentation(info="<html>
<p>SIR difference equation model</p>
</html>"));
        end diffeqmodel;

        model HPPSIR
          import CellularAutomataLib.Components.*;
          extends CellSpace(X = 100, Y = 100, neighborhood = [-1, 0; 0, -1; 0, 1; 1, 0], n_inputs = 0, wrapped_borders = 11, Tstep = 1, initial_step = 0, init_cells = [X, Y], name = "HPPSIR",
           redeclare function Rule = HPPRule,
            redeclare function Default = HPPDefault,
             redeclare function Initial = HPPSIRInitial);
          //[-1, 0; 0, -1; 0, 1; 1, 0],

          function HPPRule "Transition function"
            input CS space;
            output Integer out;

            external "C" out = HPPStep(space);
            annotation (
              Include = "#include <c17hpp.c>", Documentation(info="<html>
<p>HPP transition function</p>
</html>"));
          end HPPRule;

          function HPPDefault "Default state function"
            input CS space;
            output Integer out;

            external "C" out = HPPDefault(space);
            annotation (
              Include = "#include <c17hpp.c>", Documentation(info="<html>
<p>HPP default state function</p>
</html>"));
          end HPPDefault;

          function HPPSIRInitial "Initialization function"
            input CS space;
            input Integer x;
            input Integer y;
            input Integer z;

            external "C" HPPSIRInitial(space, x, y);
            annotation (
              Include = "#include <c17hpp.c>", Documentation(info="<html>
<p>HPP initial state function</p>
</html>"));
          end HPPSIRInitial;
          annotation (
            experiment(StopTime = 30),
            __Dymola_experimentSetupOutput,
            Documentation(info="<html>
<p>CA SIR model using an HPP approach.</p>
</html>"));
        end HPPSIR;

        model FHPSIR
          import CellularAutomataLib.Components.*;
          extends CellSpace(X = 100, Y = 100, neighborhood = [-1, 0; -1, 1; 0, -1; 0, 1; 1, 0; 1, 1], n_inputs = 0, wrapped_borders = 11, Tstep = 1, initial_step = 0,init_cells = [X, Y], name = "FHPSIR",
            redeclare function Rule = FHPRule,
            redeclare function Default = FHPDefault,
            redeclare function Initial = FHPSIRInitial);
          //[-1, 0; 0, -1; 0, 1; 1, 0],

          function FHPRule "Transition function"
            input CS space;
            output Integer out;

            external "C" out = FHPStep(space);
            annotation (
              Include = "#include <c17fhp.c>", Documentation(info="<html>
<p>FHP transition rule</p>
</html>"));
          end FHPRule;

          function FHPDefault "Default state function"
            input CS space;
            output Integer out;

            external "C" out = FHPDefault(space);
            annotation (
              Include = "#include <c17fhp.c>", Documentation(info="<html>
<p>FHP default state function</p>
</html>"));
          end FHPDefault;

          function FHPSIRInitial "Initialization function"
            input CS space;
            input Integer x;
            input Integer y;
            input Integer z;

            external "C" FHPSIRInitial(space, x, y,z);
            annotation (
              Include = "#include <c17fhp.c>", Documentation(info="<html>
<p>FHP initial state function</p>
</html>"));
          end FHPSIRInitial;
          annotation (
            experiment(StopTime = 30),
            __Dymola_experimentSetupOutput,
            Documentation(info="<html>
<p>CA SIR model using the FHP approach.</p>
</html>"));
        end FHPSIR;

        function FHPOutputS
          import CellularAutomataLib.Components.*;
          input CS space;
          input Integer x;
          input Integer y;
          input Integer z;
          output Real value;

          external "C" value = OutputS(space, x, y, z);
          annotation (
            Include = "#include <c17fhp.c>", Documentation(info="<html>
<p>FHP output function for S</p>
</html>"));
        end FHPOutputS;

        function FHPOutputI
          import CellularAutomataLib.Components.*;
          input CS space;
          input Integer x;
          input Integer y;
          input Integer z;
          output Real value;

          external "C" value = OutputI(space, x, y, z);
          annotation (
            Include = "#include <c17fhp.c>", Documentation(info="<html>
<p>FHP output function for I</p>
</html>"));
        end FHPOutputI;

        function FHPOutputR
          import CellularAutomataLib.Components.*;
          input CS space;
          input Integer x;
          input Integer y;
          input Integer z;
          output Real value;

          external "C" value = OutputR(space, x, y, z);
          annotation (
            Include = "#include <c17fhp.c>", Documentation(info="<html>
<p>FHP output function for R</p>
</html>"));
        end FHPOutputR;

        function HPPOutputS
          import CellularAutomataLib.Components.*;
          input CS space;
          input Integer x;
          input Integer y;
          input Integer z;
          output Real value;

          external "C" value = HPPOutputS(space, x, y, z);
          annotation (
            Include = "#include <c17hpp.c>", Documentation(info="<html>
<p>HPP output function for S</p>
</html>"));
        end HPPOutputS;

        function HPPOutputI
          import CellularAutomataLib.Components.*;
          input CS space;
          input Integer x;
          input Integer y;
          input Integer z;
          output Real value;

          external "C" value = HPPOutputI(space, x, y, z);
          annotation (
            Include = "#include <c17hpp.c>", Documentation(info="<html>
<p>HPP output function for I</p>
</html>"));
        end HPPOutputI;

        function HPPOutputR
          import CellularAutomataLib.Components.*;
          input CS space;
          input Integer x;
          input Integer y;
          input Integer z;
          output Real value;

          external "C" value = HPPOutputR(space, x, y, z);
          annotation (
            Include = "#include <c17hpp.c>", Documentation(info="<html>
<p>HPP output function for R</p>
</html>"));
        end HPPOutputR;

        model TaskA
          import CellularAutomataLib.Components.*;
          FHPSIR fHPSIR(name = "FHPSIR") annotation (
            Placement(transformation(extent = {{-60, 40}, {-40, 60}})));
          OutputRegion FHPoutS(
            XFromRange={1,100},
            YFromRange={1,100},                        Output_type = 4, output_rate = 1,
          redeclare function ExtOutput = FHPOutputS)                                                                                        annotation (
            Placement(transformation(extent = {{-80, 66}, {-60, 86}})));
          OutputRegion FHPoutI(
            XFromRange={1,100},
            YFromRange={1,100},                        Output_type = 4, output_rate = 1,
           redeclare function ExtOutput = FHPOutputI)                                                                                       annotation (
            Placement(transformation(extent = {{-60, 66}, {-40, 86}})));
          OutputRegion FHPoutR(
            XFromRange={1,100},
            YFromRange={1,100},                        Output_type = 4, output_rate = 1,
          redeclare function ExtOutput = FHPOutputR)                                                                                        annotation (
            Placement(transformation(extent = {{-40, 66}, {-20, 86}})));
          eqmodel SIReqn(I(start = 100), R(start = 0), S(start = 15000)) annotation (
            Placement(transformation(extent = {{-60, -40}, {-40, -20}})));
          HPPSIR hPPSIR(name = "HPPSIR") annotation (
            Placement(transformation(extent={{40,38},{60,58}})));
          OutputRegion HPPoutS(
            XFromRange={1,100},
            YFromRange={1,100},                        Output_type = 4, output_rate = 1,
          redeclare function ExtOutput = HPPOutputS)                                                                                        annotation (
            Placement(transformation(extent = {{20, 66}, {40, 86}})));
          OutputRegion HPPoutI(
            XFromRange={1,100},
            YFromRange={1,100},                        Output_type = 4, output_rate = 1,
           redeclare function ExtOutput = HPPOutputI)                                                                                       annotation (
            Placement(transformation(extent = {{40, 66}, {60, 86}})));
          OutputRegion HPPoutR(
            XFromRange={1,100},
            YFromRange={1,100},                        Output_type = 4, output_rate = 1,
           redeclare function ExtOutput = HPPOutputR)                                                                                       annotation (
            Placement(transformation(extent = {{60, 66}, {80, 86}})));
        equation
          connect(fHPSIR.Space, FHPoutI.FROM) annotation (
            Line(points={{-49,61},{-49,68},{-50,68},{-50,76}},
                                                  color = {0, 0, 255}, smooth = Smooth.None));
          connect(HPPoutS.FROM, hPPSIR.Space) annotation (
            Line(points={{30,76},{32,76},{32,59},{51,59}},          color = {0, 0, 255}, smooth = Smooth.None));
          connect(HPPoutI.FROM, hPPSIR.Space) annotation (
            Line(points={{50,76},{50,59},{51,59}},
                                                color = {0, 0, 255}, smooth = Smooth.None));
          connect(HPPoutR.FROM, hPPSIR.Space) annotation (
            Line(points={{70,76},{70,59},{51,59}},        color = {0, 0, 255}, smooth = Smooth.None));
          connect(FHPoutS.FROM, fHPSIR.Space) annotation (
            Line(points={{-70,76},{-70,61},{-49,61}},        color = {0, 0, 255}, smooth = Smooth.None));
          connect(FHPoutR.FROM, fHPSIR.Space) annotation (
            Line(points={{-30,76},{-30,61},{-49,61}},        color = {0, 0, 255}, smooth = Smooth.None));
          annotation (
            Diagram(coordinateSystem(preserveAspectRatio = false, extent = {{-100, -100}, {100, 100}}), graphics),
            experiment(StopTime = 100),
            __Dymola_experimentSetupOutput,
            Documentation(info="<html>
<p>Model that implements the Task A of the benchmark. It compares the results of the differential equation, the HPP and the FHP models.</p>
</html>"));
        end TaskA;

        model FHPSIRfull
          import CellularAutomataLib.Components.*;
          extends CellSpace(X = 100, Y = 100, neighborhood = [-1, 0; -1, 1; 0, -1; 0, 1; 1, 0; 1, 1], n_inputs = 0, wrapped_borders = 11, Tstep = 1, initial_step = 0,init_cells = [X, Y], name = "FHPSIRfull",
            redeclare function Rule = FHPRule,
            redeclare function Default = FHPDefault,
            redeclare function Initial = FHPSIRInitial);
          //[-1, 0; 0, -1; 0, 1; 1, 0],

          function FHPRule "Transition function"
            input CS space;
            output Integer out;

            external "C" out = FHPStep(space);
            annotation (
              Include = "#include <c17fhp.c>", Documentation(info="<html>
<p>FHP transition function</p>
</html>"));
          end FHPRule;

          function FHPDefault "Default state function"
            input CS space;
            output Integer out;

            external "C" out = FHPDefault(space);
            annotation (
              Include = "#include <c17fhp.c>", Documentation(info="<html>
<p>FHP default state function</p>
</html>"));
          end FHPDefault;

          function FHPSIRInitial "Initialization function"
            input CS space;
            input Integer x;
            input Integer y;
            input Integer z;

            external "C" FHPSIRInitialFull(space, x, y, z);
            annotation (
              Include = "#include <c17fhp.c>", Documentation(info="<html>
<p>FHP initial state function</p>
</html>"));
          end FHPSIRInitial;
          annotation (
            experiment(StopTime = 30),
            __Dymola_experimentSetupOutput,
            Documentation(info="<html>
<p>FHP model that includes vaccination individuals in the entire cellular space</p>
</html>"));
        end FHPSIRfull;

        model FHPSIRhalf
          import CellularAutomataLib.Components.*;
          extends CellSpace(X = 100, Y = 100, neighborhood = [-1, 0; -1, 1; 0, -1; 0, 1; 1, 0; 1, 1], n_inputs = 0, wrapped_borders = 11, Tstep = 1, initial_step = 0,init_cells = [X, Y], name = "FHPSIRhalf",
            redeclare function Rule = FHPRule,
            redeclare function Default = FHPDefault,
            redeclare function Initial = FHPSIRInitial);
          //[-1, 0; 0, -1; 0, 1; 1, 0],

          function FHPRule "Transition function"
            input CS space;
            output Integer out;

            external "C" out = FHPStep(space);
            annotation (
              Include = "#include <c17fhp.c>", Documentation(info="<html>
<p>Transition function</p>
</html>"));
          end FHPRule;

          function FHPDefault "Default state function"
            input CS space;
            output Integer out;

            external "C" out = FHPDefault(space);
            annotation (
              Include = "#include <c17fhp.c>", Documentation(info="<html>
<p>Default state function</p>
</html>"));
          end FHPDefault;

          function FHPSIRInitial "Initialization function"
            input CS space;
            input Integer x;
            input Integer y;
            input Integer z;

            external "C" FHPSIRInitialHalf(space, x, y, z);
            annotation (
              Include = "#include <c17fhp.c>", Documentation(info="<html>
<p>Initial state function</p>
</html>"));
          end FHPSIRInitial;
          annotation (
            experiment(StopTime = 30),
            __Dymola_experimentSetupOutput,
            Documentation(info="<html>
<p>FHP model that includes vaccination individuals in half of the cellular space</p>
</html>"));
        end FHPSIRhalf;

        model FHPSIRborder
          import CellularAutomataLib.Components.*;
          extends CellSpace(X = 100, Y = 100, neighborhood = [-1, 0; -1, 1; 0, -1; 0, 1; 1, 0; 1, 1], n_inputs = 0, wrapped_borders = 11, Tstep = 1, initial_step = 0,init_cells = [X,Y], name = "FHPSIRborder",
            redeclare function Rule = FHPRule,
            redeclare function Default = FHPDefault,
            redeclare function Initial = FHPSIRInitial);
          //[-1, 0; 0, -1; 0, 1; 1, 0],

          function FHPRule "Transition function"
            input CS space;
            output Integer out;

            external "C" out = FHPStep(space);
            annotation (
              Include = "#include <c17fhp.c>", Documentation(info="<html>
<p>Transition function</p>
</html>"));
          end FHPRule;

          function FHPDefault "Default state function"
            input CS space;
            output Integer out;

            external "C" out = FHPDefault(space);
            annotation (
              Include = "#include <c17fhp.c>", Documentation(info="<html>
<p>Default state function</p>
</html>"));
          end FHPDefault;

          function FHPSIRInitial "Initialization function"
            input CS space;
            input Integer x;
            input Integer y;
            input Integer z;

            external "C" FHPSIRInitialBorder(space, x, y, z);
            annotation (
              Include = "#include <c17fhp.c>", Documentation(info="<html>
<p>Initial state function</p>
</html>"));
          end FHPSIRInitial;
          annotation (
            experiment(StopTime = 30),
            __Dymola_experimentSetupOutput,
            Documentation(info="<html>
<p>FHP model that includes vaccination individuals in the border of the cellular space</p>
</html>"));
        end FHPSIRborder;

        model TaskB
          import CellularAutomataLib.Components.*;
          FHPSIRfull fHPSIRfull(name = "FHPSIRfull") annotation (
            Placement(transformation(extent = {{-60, 38}, {-40, 58}})));
          OutputRegion Ifull(
            XFromRange={1,100},
            YFromRange={1,100},                      Output_type = 4, output_rate = 1,
          redeclare function ExtOutput = FHPOutputI)                                                                                      annotation (
            Placement(transformation(extent = {{-32, 52}, {-12, 72}})));
          eqmodel eqmodel1(S(start = 12000), R(start = 4000)) annotation (
            Placement(transformation(extent = {{40, 40}, {60, 60}})));
          FHPSIRhalf fHPSIRhalf(name = "FHPSIRhalf") annotation (
            Placement(transformation(extent = {{-56, -30}, {-36, -10}})));
          OutputRegion Ihalf(
            XFromRange={1,100},
            YFromRange={1,100},                      Output_type = 4, output_rate = 1,
          redeclare function ExtOutput = FHPOutputI)                                                                                      annotation (
            Placement(transformation(extent = {{-32, -16}, {-12, 4}})));
          FHPSIRborder fHPSIRborder(name = "FHPSIborder") annotation (
            Placement(transformation(extent={{42,-28},{62,-8}})));
          OutputRegion Iborder(
            XFromRange={1,100},
            YFromRange={1,100},                        Output_type = 4, output_rate = 1,
          redeclare function ExtOutput = FHPOutputI)                                                                                        annotation (
            Placement(transformation(extent = {{68, -16}, {88, 4}})));
        equation
          connect(fHPSIRfull.Space, Ifull.FROM) annotation (
            Line(points={{-49,59},{-49,62},{-22,62}},        color = {0, 0, 255}, smooth = Smooth.None));
          connect(fHPSIRhalf.Space, Ihalf.FROM) annotation (
            Line(points={{-45,-9},{-45,-6},{-22,-6}},         color = {0, 0, 255}, smooth = Smooth.None));
          connect(fHPSIRborder.Space, Iborder.FROM) annotation (
            Line(points={{53,-7},{53,-6},{78,-6}},         color = {0, 0, 255}, smooth = Smooth.None));
          annotation (
            Diagram(coordinateSystem(preserveAspectRatio = false, extent = {{-100, -100}, {100, 100}}), graphics),
            experiment(StopTime = 100),
            __Dymola_experimentSetupOutput,
            Documentation(info="<html>
<p>Model to implement the Task B of the benchmark. This model compares the evolution of the differential equation and the FHP models, with different vaccination approaches. </p>
</html>"));
        end TaskB;

        model FHPSIRRearrange
          import CellularAutomataLib.Components.*;
          extends CellSpace(X = 100, Y = 100, neighborhood = [-1, 0; -1, 1; 0, -1; 0, 1; 1, 0; 1, 1], n_inputs = 0, wrapped_borders = 11, Tstep = 1, initial_step = 0,init_cells = [X, Y], name = "FHPSIRRearrange",
            redeclare function Rule = FHPRule,
            redeclare function Default = FHPDefault,
            redeclare function Initial = FHPSIRInitial);
          //[-1, 0; 0, -1; 0, 1; 1, 0],

          function FHPRule "Transition function"
            input CS space;
            output Integer out;

            external "C" out = FHPStepR(space);
            annotation (
              Include = "#include <c17fhp.c>", Documentation(info="<html>
<p>Transition function. This function includes the rearrangement of the individuals.</p>
</html>"));
          end FHPRule;

          function FHPDefault "Default state function"
            input CS space;
            output Integer out;

            external "C" out = FHPDefault(space);
            annotation (
              Include = "#include <c17fhp.c>", Documentation(info="<html>
<p>Default state function</p>
</html>"));
          end FHPDefault;

          function FHPSIRInitial "Initialization function"
            input CS space;
            input Integer x;
            input Integer y;
            input Integer z;

            external "C" FHPSIRInitial2(space, x, y, z);
            annotation (
              Include = "#include <c17fhp.c>", Documentation(info="<html>
<p>Initial state function</p>
</html>"));
          end FHPSIRInitial;
          annotation (
            experiment(StopTime = 30),
            __Dymola_experimentSetupOutput,
            Documentation(info="<html>
<p>Model that includes the random rearrangement of individuals along the cellular space, in order to represent the homogeneous distribution of individuals considered in the differential equation model.</p>
</html>"));
        end FHPSIRRearrange;

        model TaskC
          FHPSIRRearrange fHPSIR(name = "FHPSIR") annotation (
            Placement(transformation(extent = {{-60, 40}, {-40, 60}})));
          Components.OutputRegion SIRrearrangeI(XFromRange = {0,100}, YFromRange = {0,100}, Output_type = 4, output_rate = 1, redeclare
              function ExtOutput =                                                                                                    FHPOutputI)
                                                                                                                                                  annotation (
            Placement(transformation(extent = {{-60, 66}, {-40, 86}})));
          eqmodel Eqnmodel(I(start = 1000), R(start = 0), S(start = 40000)) annotation (
            Placement(transformation(extent = {{-60, -40}, {-40, -20}})));
          FHPSIR fHPSIR1(name = "FHPSIR") annotation (
            Placement(transformation(extent={{32,40},{52,60}})));
          Components.OutputRegion SIR(XFromRange = {0,100}, YFromRange = {0,100}, Output_type = 4, output_rate = 1, redeclare
              function ExtOutput =                                                                                          FHPOutputI)
                                                                                                                                        annotation (
            Placement(transformation(extent = {{32, 66}, {52, 86}})));
          diffeqmodel Diffeqmodel(S(start = 40000), I(start = 1000), r = 0.00003) annotation (
            Placement(transformation(extent = {{-60, 0}, {-40, 20}})));
        equation
          connect(fHPSIR.Space, SIRrearrangeI.FROM) annotation (
            Line(points={{-49,61},{-49,68},{-50,68},{-50,76}},
                                                  color = {0, 0, 255}, smooth = Smooth.None));
          connect(fHPSIR1.Space, SIR.FROM) annotation (
            Line(points={{43,61},{43,68},{42,68},{42,76}},
                                                color = {0, 0, 255}, smooth = Smooth.None));
          annotation (
            Diagram(coordinateSystem(preserveAspectRatio = false, extent = {{-100, -100}, {100, 100}}), graphics),
            experiment(StopTime = 100),
            __Dymola_experimentSetupOutput,
            Documentation(info="<html>
<p>Model that implements the Task C of the benchmark. This model compares the FHP model, with and without rearrangement, with both equation models.</p>
</html>"));
        end TaskC;
        annotation (Documentation(info="<html>
<p>Package that contains the implementation of the C17 ARGESIM benchmark model.</p>
</html>"));
      end C17;

      package C19
        model Pollution
          import CellularAutomataLib.Components.*;
          extends CellSpace(X = 40, Y = 70, neighborhood = [-1, -1; -1, 0; -1, 1; 0, -1; 0, 1; 1, -1; 1, 0; 1, 1], n_inputs = 0, wrapped_borders = 0, Tstep = 1, initial_step = 0, init_cells = {{20, 10}}, name = "Pollution",
            redeclare function Rule = POLRule,
            redeclare function Default = POLDefault,
            redeclare function Initial = POLInitial);
          //[-1, 0; 0, -1; 0, 1; 1, 0],

          function POLRule "Transition function"
            input CS space;
            output Integer out;

            external "C" out = POLStep(space);
            annotation (
              Include = "#include <c19.c>", Documentation(info="<html>
<p>Transition function</p>
</html>"));
          end POLRule;

          function POLDefault "Default state function"
            input CS space;
            output Integer out;

            external "C" out = POLDefault(space);
            annotation (
              Include = "#include <c19.c>", Documentation(info="<html>
<p>Default state function</p>
</html>"));
          end POLDefault;

          function POLInitial "Initialization function"
            input CS space;
            input Integer x;
            input Integer y;
            input Integer z;

            external "C" POLInitial(space, x, y, z);
            annotation (
              Include = "#include <c19.c>", Documentation(info="<html>
<p>Initial state function</p>
</html>"));
          end POLInitial;
          annotation (
            experiment,
            __Dymola_experimentSetupOutput,
            Documentation(info="<html>
<p>Model to describe the spread of groundwater polutants </p>
</html>"));
        end Pollution;

        function ExtOutput
          import CellularAutomataLib.Components.*;
          input CS space;
          input Integer x;
          input Integer y;
          input Integer z;
          output Real value;

          external "C" value = Output(space, x, y, z);
          annotation (
            Include = "#include <c19.c>", Documentation(info="<html>
<p>Output function</p>
</html>"));
        end ExtOutput;

        model TaskA
          import CellularAutomataLib.Components.*;
          Pollution pollution(X = 70) annotation (
            Placement(transformation(extent = {{-58, -2}, {-38, 18}})));
          OutputRegion MAXc0(
            XFromRange={10,10},
            YFromRange={20,20},                                              output_rate = 1, redeclare
              function ExtOutput =                                                                                                   ExtOutput, Output_type = 2) annotation (
            Placement(transformation(extent = {{-20, 40}, {0, 60}})));
          OutputRegion MAXc10(
            XFromRange={20,20},
            YFromRange={20,20},                       output_rate = 1,                         redeclare
              function ExtOutput =                                                                                                    ExtOutput, Output_type = 2) annotation (
            Placement(transformation(extent = {{-20, 20}, {0, 40}})));
          OutputRegion MAXc20(
            XFromRange={30,30},
            YFromRange={20,20},                       output_rate = 1,                         redeclare
              function ExtOutput =                                                                                                    ExtOutput, Output_type = 2) annotation (
            Placement(transformation(extent={{-20,2},{0,22}})));
          OutputRegionM C50(
            XFromRange={50,50},
            YFromRange={1,40},                                             output_rate = 1, redeclare
              function ExtOutput =                                                                                                 ExtOutput)
                                                                                                                                              annotation (
            Placement(transformation(extent = {{-20, -40}, {0, -20}})));
        equation
          connect(pollution.Space, MAXc0.FROM) annotation (
            Line(points={{-47,19},{-47,30},{-28,30},{-28,50},{-10,50}},            color = {0, 0, 255}, smooth = Smooth.None));
          connect(pollution.Space, MAXc10.FROM) annotation (
            Line(points={{-47,19},{-47,30},{-10,30}},        color = {0, 0, 255}, smooth = Smooth.None));
          connect(pollution.Space, MAXc20.FROM) annotation (
            Line(points={{-47,19},{-47,30},{-28,30},{-28,12},{-10,12}},            color = {0, 0, 255}, smooth = Smooth.None));
          connect(C50.FROM, pollution.Space) annotation (
            Line(points={{-10,-30},{-28,-30},{-28,-28},{-47,-28},{-47,19}},            color = {0, 0, 255}, smooth = Smooth.None));
          annotation (
            Diagram(coordinateSystem(preserveAspectRatio = false, extent = {{-100, -100}, {100, 100}}), graphics),
            experiment(StopTime = 1200),
            __Dymola_experimentSetupOutput,
            Documentation(info="<html>
<p>Implementation of the Task A of the benchmark. This model includes a Pollution model and several output region models to observe the evolution of the pollutant spread.</p>
</html>"));
        end TaskA;

        function ExtInput
          import CellularAutomataLib.Components.*;
          input CS space;
          input Integer x;
          input Integer y;
          input Integer z;
          input Real value;
          input Integer input_id;

          external "C" EInput(space, x, y, z, value, input_id);
          annotation (
            Include = "#include <c19.c>", Documentation(info="<html>
<p>External input function</p>
</html>"));
        end ExtInput;

        model TaskB
          import CellularAutomataLib.Components.*;
          Pollution pollution(n_inputs = 2, X = 70) annotation (
            Placement(transformation(extent = {{-12, 0}, {8, 20}})));
          OutputRegion MAXc0(
            XFromRange={10,10},
            YFromRange={20,20},                                              output_rate = 1, redeclare
              function ExtOutput =                                                                                                   ExtOutput, Output_type = 2) annotation (
            Placement(transformation(extent = {{26, 42}, {46, 62}})));
          OutputRegion MAXc10(
            XFromRange={20,20},
            YFromRange={20,20},                       output_rate = 1,                         redeclare
              function ExtOutput =                                                                                                  ExtOutput, Output_type = 2) annotation (
            Placement(transformation(extent={{26,24},{46,44}})));
          OutputRegion MAXc20(
            XFromRange={30,30},
            YFromRange={20,20},                       output_rate = 1,                         redeclare
              function ExtOutput =                                                                                                    ExtOutput, Output_type = 2) annotation (
            Placement(transformation(extent = {{26, 2}, {46, 22}})));
          OutputRegionM C50(
            XFromRange={50,50},
            YFromRange={1,40},                                             output_rate = 1, redeclare
              function ExtOutput =                                                                                                 ExtOutput)
                                                                                                                                              annotation (
            Placement(transformation(extent = {{26, -38}, {46, -18}})));
          ExtInputRegion PlantA(
            XToRange={35,45},
            YToRange={10,20},                                                   Input_type = 5, q_t = 1, redeclare
              function ExtInput =                                                                                                              ExtInput) annotation (
            Placement(transformation(extent = {{-60, 20}, {-40, 40}})));
          ExtInputRegion PlantB(
            XToRange={35,45},
            YToRange={20,30},                           Input_type = 5, q_t = 1,                         input_id = 2, redeclare
              function ExtInput =                                                                                                                            ExtInput) annotation (
            Placement(transformation(extent = {{-60, -20}, {-40, 0}})));
          Modelica.Blocks.Sources.Constant const(k = 2) annotation (
            Placement(transformation(extent = {{-90, 18}, {-70, 38}})));
        equation
          connect(pollution.Space, MAXc0.FROM) annotation (
            Line(points={{-1,21},{-1,32},{18,32},{18,52},{36,52}},            color = {0, 0, 255}, smooth = Smooth.None));
          connect(pollution.Space, MAXc10.FROM) annotation (
            Line(points={{-1,21},{-1,34},{36,34}},        color = {0, 0, 255}, smooth = Smooth.None));
          connect(pollution.Space, MAXc20.FROM) annotation (
            Line(points={{-1,21},{-1,32},{18,32},{18,12},{36,12}},            color = {0, 0, 255}, smooth = Smooth.None));
          connect(C50.FROM, pollution.Space) annotation (
            Line(points={{36,-28},{18,-28},{18,-26},{-1,-26},{-1,21}},            color = {0, 0, 255}, smooth = Smooth.None));
          connect(PlantA.TO, pollution.Space) annotation (
            Line(points={{-47,30},{-24,30},{-24,21},{-1,21}},          color = {0, 0, 255}, smooth = Smooth.None));
          connect(PlantB.TO, pollution.Space) annotation (
            Line(points={{-47,-10},{-24,-10},{-24,21},{-1,21}},          color = {0, 0, 255}, smooth = Smooth.None));
          connect(const.y, PlantA.u) annotation (
            Line(points = {{-69, 28}, {-64, 28}, {-64, 30}, {-58, 30}}, color = {0, 0, 127}, smooth = Smooth.None));
          connect(const.y, PlantB.u) annotation (
            Line(points = {{-69, 28}, {-69, 10}, {-58, 10}, {-58, -10}}, color = {0, 0, 127}, smooth = Smooth.None));
          annotation (
            Diagram(coordinateSystem(preserveAspectRatio = false, extent = {{-100, -100}, {100, 100}}), graphics),
            experiment(StopTime = 1300),
            __Dymola_experimentSetupOutput,
            Documentation(info="<html>
<p>Implementation of the Task B of the benchmark. Additionally to Task A, this model also includes two external input functions that activate pollution reduction actions. </p>
</html>"));
        end TaskB;

        annotation (Documentation(info="<html>
<p>Package that contains the implementation of the C19 ARGESIM benchmark model.</p>
</html>"));
      end C19;

      package LBM

        function LBMDisplay
          input Components.CS space;

          external "C" D2Q9SetDisplay(space);
          annotation (Include = "#include <LBM.c>", Documentation(info="<html>
<p>Display function</p>
</html>"));

        end LBMDisplay;

        model LBM_SimpleWave
          import CellularAutomataLib.Components.*;
          extends CellSpace(X = 10, Y = 10, hex = 0, neighborhood = [-1,-1;-1,0;-1,1;0,1;1,1;1,0;1,-1;0,-1], n_inputs = 0, wrapped_borders = 11, Tstep = 1, initial_step = 0, init_cells = [X, Y], name = "Simple Diffusion",
            redeclare function Rule = LBMRule,
            redeclare function Default = LBMDefault,
            redeclare function Initial = LBMInitial);

             function LBMRule "Transition function"
               input CS space;
               output Integer out;

             external"C" out = D2Q9Step(space);
               annotation (
              Include = "#include \"LBM.c\"", Documentation(info="<html>
<p>Transition function</p>
</html>"));
             end LBMRule;

          function LBMDefault "Default state function"
            input CS space;
            output Integer out;

            external "C" out = D2Q9Default(space);
            annotation (
              Include = "#include \"LBM.c\"", Documentation(info="<html>
<p>Default state function</p>
</html>"));
          end LBMDefault;

          function LBMInitial "Initialization function"
            input CS space;
            input Integer x;
            input Integer y;
            input Integer z;

            external "C" D2Q9InitialSimpleWave(space, x,y,z);
            annotation (
              Include = "#include \"LBM.c\"", Documentation(info="<html>
<p>Initial state function</p>
</html>"));
          end LBMInitial;

          annotation (experiment(StopTime=5, __Dymola_Algorithm="Dassl"),
              Documentation(info="<html>
<p>Model that simulates the evolution of a simple wave using a LBM model.</p>
</html>"));
        end LBM_SimpleWave;

        model LBM_SimpleWave_Animation
          parameter Integer X = 100;
          parameter Integer Y = 100;
          LBM_SimpleWave simpleDiffusion(
            X=X,
            Y=Y,
            hex=0,
            wrapped_borders=11)
            annotation (Placement(transformation(extent={{-40,-18},{-20,2}})));
          Components.Animation animation(
            WindowX=X,
            WindowY=Y,
            displayDelay=100000,                                  redeclare
              function
              SetDisplayFunction =                                                                          LBMDisplay)
            annotation (Placement(transformation(extent={{-2,-20},{18,0}})));
        equation
          connect(simpleDiffusion.Space, animation.Space)
            annotation (Line(points={{-29,3},{-29,14},{8,14},{8,1}},  color={0,0,0}));
          annotation (Icon(coordinateSystem(preserveAspectRatio=false)), Diagram(
                coordinateSystem(preserveAspectRatio=false)),
            experiment(StopTime=200, __Dymola_Algorithm="Dassl"),
            Documentation(info="<html>
<p>Model that includes the LBM_SimpleWave model and an Animation model to generate the graphical animation. The wave starts in the center of the cellular space and propagates. Wrapped boundary conditions are used. A display delay is also used in the animation to better observe the evolution of the wave.</p>
</html>"));
        end LBM_SimpleWave_Animation;

        model LBM_Unsteady
          import CellularAutomataLib.Components.*;
          extends CellSpace(X = 10, Y = 10, hex = 0, neighborhood = [-1,-1;-1,0;-1,1;0,1;1,1;1,0;1,-1;0,-1], n_inputs = 0, wrapped_borders = 0, Tstep = 1, initial_step = 0, init_cells = [X, Y], name = "Simple Diffusion",
            redeclare function Rule = LBMRule,
            redeclare function Default = LBMDefault,
            redeclare function Initial = LBMInitial);

             function LBMRule "Transition function"
            input CS space;
            output Integer out;

          external"C" out = D2Q9Step(space);
            annotation (
              Include = "#include \"LBM.c\"", Documentation(info="<html>
<p>Transition function</p>
</html>"));
             end LBMRule;

          function LBMDefault "Default state function"
            input CS space;
            output Integer out;

            external "C" out = D2Q9Default(space);
            annotation (
              Include = "#include \"LBM.c\"", Documentation(info="<html>
<p>Default state function</p>
</html>"));
          end LBMDefault;

          function LBMInitial "Initialization function"
            input CS space;
            input Integer x;
            input Integer y;
            input Integer z;

            external "C" D2Q9InitialUnsteady(space, x,y,z);
            annotation (
              Include = "#include \"LBM.c\"", Documentation(info="<html>
<p>Initial state function</p>
</html>"));
          end LBMInitial;

          annotation (experiment(StopTime=5, __Dymola_Algorithm="Dassl"),
              Documentation(info="<html>
<p>LBM model to simulate a Von Karman vortex street.</p>
</html>"));
        end LBM_Unsteady;

        model LBM_Unsteady_Animation
          parameter Integer X = 250;
          parameter Integer Y = 50;
          LBM_Unsteady unsteady(
            X=X,
            Y=Y,
            hex=0,
            wrapped_borders=10)
            annotation (Placement(transformation(extent={{-40,-18},{-20,2}})));
          Components.Animation animation(
            WindowX=X,
            WindowY=Y,
            displayDelay=10000,                                  redeclare
              function SetDisplayFunction =                                                                 LBMDisplay)
            annotation (Placement(transformation(extent={{-2,-20},{18,0}})));
        equation
          connect(unsteady.Space, animation.Space)
            annotation (Line(points={{-29,3},{-29,14},{8,14},{8,1}}, color={0,0,0}));
          annotation (Icon(coordinateSystem(preserveAspectRatio=false)), Diagram(
                coordinateSystem(preserveAspectRatio=false)),
            Documentation(info="<html>
<p>This model includes an LBM_Unstead model and an Animation model to simulate the Von Karman vortex street.</p>
</html>"));
        end LBM_Unsteady_Animation;
        annotation (Documentation(info="<html>
<p>Package that contains the implementation of Lattice Boltzman Models.</p>
<p>External C code is located in the <span style=\"font-family: monospace;\">LBM.c </span>file</p>
</html>"));
      end LBM;

      annotation (Documentation(info="<html>
<p>Examples of 2D CA models.</p>
</html>"));
    end CS_2D;

    package CS_3D
      package Simple
        model Clouds1
          import CellularAutomataLib.Components.*;
          extends CellSpace(
            X=100,
            Y=100,
            Z=100,
            init_cells=[X,Y,Z],
            redeclare function Default = S3Default,
            redeclare function Initial = S3RandomInit,
            redeclare function Rule = S3Rule);

            function S3Default
            input CS space;
            output Integer out;

            external "C" out = S3Default(space);
            annotation (
              Include = "#include \"s3.c\"", Documentation(info="<html>
<p>Default state function</p>
</html>"));
            end S3Default;

          function S3RandomInit
            input CS space;
            input Integer x;
            input Integer y;
            input Integer z;

            external "C" S3RandomInitial(space, x, y, z);
            annotation (
              Include = "#include \"s3.c\"", Documentation(info="<html>
<p>Initial state function</p>
</html>"));
          end S3RandomInit;

          function S3Rule
            input CS space;
            output Integer out;

            external "C" out = S3Clouds1Step(space);
            annotation (
              Include = "#include \"s3.c\"", Documentation(info="<html>
<p>Transition function</p>
</html>"));
          end S3Rule;

          annotation (experiment(StopTime=200, __Dymola_Algorithm="Dassl"),
              Documentation(info="<html>
<p>A life-like model with the rule B13-19/S13-26. A dead cell becomes alive with 13 to 19 neighbors alive. A living cell survives with more than 12 neighbors alive. </p>
</html>"));
        end Clouds1;

        function CloudsDisplay
            input Components.CS space;

          external "C" SetDisplayClouds(space);
          annotation (Include = "#include <s3.c>", Documentation(info="<html>
<p>Display function for the Clouds1 model</p>
</html>"));

        end CloudsDisplay;

        model Clouds_Anim
          Clouds1 clouds1_1( X=100,Y=100,Z=100)
            annotation (Placement(transformation(extent={{-40,-20},{-20,0}})));
          Components.Animation animation(
            WindowX=100,
            WindowY=100,
            WindowZ=100,
            redeclare function SetDisplayFunction = CloudsDisplay,
            name="Clouds")
            annotation (Placement(transformation(extent={{2,-20},{22,0}})));
        equation
          connect(clouds1_1.Space, animation.Space)
            annotation (Line(points={{-29,1},{-29,10},{12,10},{12,1}}, color={0,0,0}));
          annotation (Icon(coordinateSystem(preserveAspectRatio=false)), Diagram(
                coordinateSystem(preserveAspectRatio=false)),
            Documentation(info="<html>
<p>Model that combines Clouds1 with an Animation model.</p>
</html>"));
        end Clouds_Anim;

        model Rule445
          import CellularAutomataLib.Components.*;
          extends CellSpace( X = 100, Y = 100, Z = 100,
          init_cells = [50,50,50; 49,50,50; 50,49,50; 49,49,50;
                        50,50,49; 49,50,49; 50,49,49; 49,49,49;
                        50,50,51; 49,50,51; 50,49,51; 49,49,51],
             redeclare function Default = S3Default,
            redeclare function Initial = S3Init,
            redeclare function Rule = S3445Step);

            function S3Default
            input CS space;
            output Integer out;

            external "C" out = S3Default(space);
            annotation (
              Include = "#include \"s3.c\"", Documentation(info="<html>
<p>Default state function</p>
</html>"));
            end S3Default;

          function S3Init
            input CS space;
            input Integer x;
            input Integer y;
            input Integer z;

            external "C" S3Initial(space, x, y, z);
            annotation (
              Include = "#include \"s3.c\"", Documentation(info="<html>
<p>Initial state function</p>
</html>"));
          end S3Init;

          function S3445Step
            input CS space;
            output Integer out;

            external "C" out = S3445Step(space);
            annotation (
              Include = "#include \"s3.c\"", Documentation(info="<html>
<p>Transition function</p>
</html>"));
          end S3445Step;

          annotation (Documentation(info="<html>
<p>A life-like model with the rule 445. The state of living cells is an integer number greater than 0, and with 0 representing a dead cell. In this model, living cells degrade their state until they become dead. Also, dead cells with 4 neighbors become alive and living cells with other than 4 neighbors alive become dead.</p>
</html>"));
        end Rule445;

        function Display445
            input Components.CS space;

          external "C" SetDisplay445(space);
          annotation (Include = "#include <s3.c>", Documentation(info="<html>
<p>Rule 445 display function</p>
</html>"));

        end Display445;

        model Rule445_Anim
          Rule445 rule445_1
            annotation (Placement(transformation(extent={{-40,-20},{-20,0}})));
          Components.Animation animation(
            WindowX=100,
            WindowY=100,
            WindowZ=100,
            redeclare function SetDisplayFunction = Display445,
            name="Clouds")
            annotation (Placement(transformation(extent={{2,-20},{22,0}})));
        equation
          connect(rule445_1.Space, animation.Space)
            annotation (Line(points={{-29,1},{-29,10},{12,10},{12,1}}, color={0,0,0}));
          annotation (Icon(coordinateSystem(preserveAspectRatio=false)), Diagram(
                coordinateSystem(preserveAspectRatio=false)),
            Documentation(info="<html>
<p>Model that includes a Rule445 model and an Animation model.</p>
</html>"));
        end Rule445_Anim;

        annotation (Documentation(info="<html>
<p>Package that contains simple models.</p>
<p>External C code in the <span style=\"font-family: monospace;\">s3.c</span> file</p>
</html>"));
      end Simple;

      annotation (Documentation(info="<html>
<p>Examples of 3D CA models.</p>
</html>"));
    end CS_3D;
    annotation (Documentation(info="<html>
<p>This package includes examples of CA models arranged by the number of dimensions of their cellular space.</p>
</html>"));
  end Examples;
  annotation (
    preferredView = "info",
    Documentation(info="<html>
<p><b>Cellular Automata Models in Modelica</b> </p>
<p>This library can be used to describe 1D, 2D and 3D cellular automata models in Modelica.</p> 
<p>It also includes interface models to combine cellular automata with other Modelica models. </p>
<p>In order to automatically generate the graphical animations of the simulations the <b>Raylib (<a href=\"http://www.raylib.com\">www.raylib.com</a>)</b> library program has to be installed in the computer. </p>
<h4>Author:</h4>
<p style=\"margin-left: 30px;\"><a href=\"http://www.euclides.dia.uned.es/vsanz\">Victorino Sanz </a></p>
<p style=\"margin-left: 30px;\">Dpto. Inform&aacute;tica y Autom&aacute;tica, UNED</p>
<p style=\"margin-left: 30px;\">Juan del Rosal, 16</p>
<p style=\"margin-left: 30px;\">28040, Madrid</p>
<p style=\"margin-left: 30px;\">Spain</p>
<p style=\"margin-left: 30px;\">Email: <a href=\"mailto:vsanz@dia.uned.es\">vsanz@dia.uned.es</a></p>
<p style=\"margin-left: 30px;\">Website: <a href=\"http://www.euclides.dia.uned.es/vsanz\">www.euclides.dia.uned.es/vsanz</a></p>
<h4>Copying:</h4>
<p style=\"margin-left: 30px;\"><i>Licensed by Victorino Sanz under the LGPL-3.0 or later. </p>
<p style=\"margin-left: 30px;\">Copyright 2024, Victorino Sanz.</p>
<p style=\"margin-left: 30px;\">This program is free software: you can redistribute it and/or modify it under the terms of the GNU Leaser General Public License as published by the Free Software Foundation, either version 3 of the License, or any later version.</p><p style=\"margin-left: 30px;\">This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Leaser General Public License for more details.</p><p style=\"margin-left: 30px;\">You should have received a copy of the GNU Leaser General Public License along with this program (LICENSE). If not, see &lt;https://www.gnu.org/licenses/&gt;.</p><p style=\"margin-left: 30px;\"></i></p>
</html>"),
    uses(Modelica(version="4.0.0")));
end CellularAutomataLib;
